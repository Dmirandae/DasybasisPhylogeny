   
MACROS: 
      bandb    barplot    combine   continue   copytree   chkbreak  cutbranch 
       else        end  endbranch    endloop    endswap     errmsg   forfiles 
       goto     hifile         ifiternucrecs   iterrecs  killfiles      label 
       loop   macfloat      macro  macreport    macseed  maketable    private 
   progress    recurse  resetswap  resettime     return       safe        set 
   setarray    setloop   slaveget   slaveset      sprit      tbrit   travtree 
        var       xend 
 
Expressions (enter "help+xxx" for help on xxx): 
   absicnl        accepted       allvars        argnumber      anc             
   bbfull         bbtax          biginsect      bignotsect     blockend        
   blocklist      blockstart     bigntax        bittype        break           
   bremlist       charsingp      chartonuc      clusdist       collapse        
   combin         comnod         cost           contscale      contmins        
   contmaxs       cpus           curisdir       cutswap        cygwin          
   dcomp          distnode       downlist       deslist        discoeff        
   editcost       eqgroup        eqstring       eqtrees        exp             
   exstatus       fit            firstdes       fixlik         flipd           
   freevars       freqlist       freqdlist      gcomp          getarep         
   getrandom      getresponse    gfreq          grandscore     grouplist       
   grpdist        grptogrp       gtk            havetgp        homo            
   hifchar        hifeof         hifline        hifnumber      hifspy          
   hifstring      hiftext        implik         impwtlist      intpol          
   invault        isact          isactax        isadd          issank          
   isanc          iscateg        iscont         isdefd         isdup           
   isfile         isinagroup     isinfo         isinnuc        isinstring      
   isintree       isintgroup     isinxgroup     islmark        ismono          
   lastsibyl      lastsupp       length         lenstring      listsize        
   log            lik            linux          kval           lmdims          
   lmerror        lmfactor       lmmaxdist      lmnchar        lmnpoints       
   lmscore        lmwt           lmxcell        lmxcoord       macseed         
   matexp         matchtax       maxcfork       maxstate       maxsteps        
   maxtgroups     maxtrans       maxtrees       maxval         maxvars         
   meanval        minsteps       mintrans       minval         missing         
   mklik          mplik          mono           mypid          nblocks         
   nchar          neper          nnodes         nnucs          nodfork         
   nodtosect      nstates        ntax           ntrees         nucmaxstate     
   nucmember      nucsize        nuctostate     numbits        numclads        
   numcategs      numdes         numhits        nummissing     osr             
   outgroup       percswap       piwe           power          protmode        
   randomlist     rearrangs      recsteps       regalfa        regbeta         
   regr           report         repspoly       rfdist         root            
   rseed          rsubopt        score          seclevel       seqstart        
   seqend         simgroup       simplik        sister         slerrmarg       
   smplik         softhomo       softlength     softscore      softfit         
   sortlist       spearman       splitgroup     sprdiff        sprsim          
   states         statediff      stddev         stringend      stringsim       
   subopt         sumval         symcoeff       taxinblock     taxingp         
   tcount         time           tnodes         treesingp      tripdist        
   tsize          ttaghei        ttags          ttagwid        uplist          
   usdram         varsize        vtrees         weight         whomo           
   windows        
   Parallel versions only: 
   attag          bestscore      bground        deltascore     hostload        
   isinhgroup     ntasksbelow    numerrors      numhosts       numjobs         
   numrearrangs   numreps        numtasks       numtrees       percdone        
   pexstatus      plevel         pmode          runtime        schalg          
   slavenum       speed          tagsum         tasksatsch     tasksin         
   tasksleft      tasksrecvd     tasktoh        totcpus        treeparts       
   waitsuccess     
 
 
ABSINCL
    =   in tread, send excluded taxa to tree base 
    -   exclude them from tree 
 
AGROUP
    define groups of taxa.  Syntax is as in "tgroup" (but options 
    "len", "nod", "siz", or "mono" not allowed, and  
    "agroup !;" saves only active taxa). You can also create 
    groups with taxa having specific states for a given character, 
    with "char C=S" (places or removes from group all the taxa 
    that have state S for character C; discrete characters only);  
    instead of "=", you can also use "char C>S" or "char C<S". 
 
ALLTREES
    generate all trees for active taxa 
      &   generate all polytomous trees as well. 
      *   generate all distinct (rooted) tree shapes. 
 
ANCSTATES
    N   define character(s) N as ancestral. Ancestral 
        states correspond to those of current outgroup 
 
APO
      N     plot synapomorphies for tree(s) N 
      [N    plot synapomorphies common to tree(s) N. 
      -     list instead of plotting on tree 
      [-N/L list synapomorphies common to tree(s) N, node(s) L 
      ]N    list synapomorphies common to tree(s) N, on tree 
            diagrams 
      >N    list synapomorphies common to tree(s) N, as well 
            as apomorphic states, on tree diagrams.  If ">" 
            is followed by "(N)", then plots in columns of 
            maximum width N (default = no limit) 
      !C N  for landmark configuration C, plot the individual 
            landmarks that change on each branch, for tree(s) N 
 
BBREAK
    Perform branch-swapping, using pre-existing trees as starting point. 
    Use "bbreak=options;" (change settings and run) or "bbreak:options;" 
    (change settings, don't run).  This swaps according to current settings 
    of suboptimal, constraints, and collapsing. 
      
    Basic options are: 
      tbr         use TBR 
      spr         use SPR 
     [no]fillonly swap until tree-buffer is filled, and then stop. 
     [no]mulpars  save multiple trees. 
      
    Fine-tuning options are: 
     [no]safe     The "safe" option uses a slower (but safer) method for 
                  updating buffers when finding a better tree under TBR 
                  (default is "nosafe"). 
     [no]skipspr skips the SPR phase on a single tree when doing multiple 
                  RAS+TBR saving several trees per replication; "skipspr" 
                  is useful in conjunction with "nosafe", but not so much 
                  with "safe" because then the initial portion of TBR 
                  (when better trees are being found often) gets slowed down 
                  and SPR doesn't.  The "nosafe" option only makes a  
                  difference for very large data sets; note that "skipspr" 
                  modifies the behaviour of both "mult" and "xmult". 
     [no]int N    There are two options, "int 1" and "int 2" (both options 
                  identify most relevant characters for a series of swaps, 
                  option 2 also reorders characters to try to save time). 
                  These options useful only for large matrices (>10,000) with 
                  large numbers of characters; otherwise they tend to produce 
                  slower swapping. 
     [no]randclip randomize clipping sequence (with current random seed). 
     [no]xbit     On 64-bit systems, the (default) "xbit" option turns on 
                  optimization using 64 bits, when possible.  This tends to  
                  be 20-25% faster. 
     [no]preproc  with "preproc" the program tries to identify and effect 
                   first the clippings that would improve the tree the most; 
                  this has effect only on "mult" searches with hold=1 (and 
                  only when skipping the SPR phase), and TBR swapping from  
                  existing trees with mulpars off.  This may save a little  
                  time in the initial stages of the search for very large 
                  data sets, although the end gain is small. 
     clusters N   use node-clusters of N nodes.  As the data set becomes  
                  larger, clusters of more nodes produce faster TBR-swapping. 
                  When using clusters also for wagner trees, the same size as 
                  defined here is used. 
     [no]strat    for landmarks only; use a "stratified" error margin (i.e. 
                  begin low, increase as swapping advances, as set with "lmark 
                  errmarg") for the first tree swapped, final error for the  
                  last one.  Otherwise, use the final error margin from the 
                  the beginning of the swapping (intended for trees that are  
                  already optimal or near-optimal). 
      
    Included for comparability with PAUP*: 
     [no]limit N  when doing TBR, only use destinations and rerooting no more  
                  than N nodes away from the original.  Using a narrow limit  
                  in large trees makes it look at only a tiny fraction of the 
                  rearrangements, thus speeding up the search, but also making  
                  it much less likely to find the optimal tree.  Using a large 
                  limit increases the chances of finding the optimal trees, but 
                  when using this, shortcuts used in the absence of a limit are 
                  not applicable, with the result that swapping with large 
                  limits (probably above 1/4 to 1/3 of the taxa) produces a  
                  slower TBR than swapping with no limit at all.  Thus, the use 
                  of this option is discouraged, except to make comparisons with 
                  other software using this option. N.B.: the use of limits is  
                  compatible with constraints, but when using constraints with 
                  limited TBR, only the rearrangements effectively done are  
                  counted (in contrast to the default, unlimited  TBR, which 
                  counts rearrangements violating constraints as done and  
                  rejected). 
 
BEEP
    =   beep on errors and warning messages 
    -   don't (default) 
 
BEST
    filter trees, discarding suboptimal 
    N   keep trees up to N steps (weighted) worse than best 
    -   invert the selection criterion 
    [   discard trees not fulfilling constraints of monophyly 
    ]   discard trees fulfilling them 
    *   collapse the trees before comparing 
 
BGROUND
    as first argument when calling TNT, it tells it to run in background.
 
    Files recognized while in background:
 
      stop_tnt_PID     if file exists, interrupts (as if pressing <esc>). 
                       Note that if program is in a "wait" loop, then this 
                       (just like <esc>) interrupts the wait and programs  
                       continues with instructions subsequent to the "wait" 
                       (unless "execute_tnt_PID" exists, case in which, 
                       TNT switches immediately to that file).  Thus, if the 
                       program is in a "wait" loop, stop_tnt_PID may have 
                       to be created a second time for immediate exit.
 
      pause_tnt_PID    if file exists, TNT is paused (as if pressing "p"). 
                       When TNT paused, removing file resumes work.
 
      execute_tnt_PID  when TNT finishes current set of instructions (or 
                       when interrupted with stop_tnt_PID), uses contents 
                       of file as new set of instructions (moving already 
                       executed instructions to file ".tntexec_N_PID", where 
                       N increases as TNT continues being reset). This is 
                       not recognized by slaves, and works only after normal 
                       termination (if in backgrond, errors cause an exit).
 
    Except for "execute_tnt_PID", file contents are irrelevant; TNT only 
    checks existence of the file itself. 
 
BLENGTH
    N;    show table with branch lengths for tree(s) N. For 
          step-matrix characters, particularly those with  
          asymmetric transformation costs, this is only an 
          approximation. 
    *N;   same, using a tree diagram 
    /N;   for tree(s) N, show cost of collapsing the branch 
          under standard implied weights (exact for additive/ 
          nonadditive characters, approximate otherwise, 
          particularly for characters with asymmetric  
          transformation costs and inapplicables). 
    > N/L for continuous characters, show maximum increase in value 
          for each branch, for tree(s) N, char(s) L.  If a branch  
          always decreases, show minimum decrease.  From command  
          line, '[' can be used instead; this can be used together 
          with '<' (see below) 
    < N/L for continuous characters, show maximum decrease, as for '>'.  
          If a branch always increases, show minimum increase. From 
          command line, ']' can be used instead. 
 
BLOCKS
    J K L   Define blocks to start at character(s) J K L 
    ;       Show current blocks 
    *;      Save curent blocks 
    = J K   deactivate all characters and taxa not in blocks  
            J K (if list preceded by "&", only shared taxa 
            remain active) 
 
BREAK
    =   enable breaks with <esc>, pauses with 'p' (default). During 
        searches, pressing 'm' will stop the search and move on 
        (executing the rest of commands from file or console). 
    -   don't 
    /   copy text (ending with semicolon) to display as warning if 
        calculations are interrupted ("yes" interrupts anyway) 
        By default, interruption produces no queries 
 
BSUPPORT
    Calculate bremer supports, using trees currently in memory.
 
    N/L   use tree(s) N, pruning taxon (taxa) L, and display results
 
    Other options:
 
      =N    collapse groups with support < N. If using the "!" option, 
            N can be negative; otherwise, N must be >= 0. 
      *     save tree as last tree in memory 
      [     use relative (instead of absolute) supports 
      ]     use relative supports, using only trees within absolute support 
      !N    calculate supports by TBR-swapping, for groups in tree N.  If 
            N preceded by '+' then it adds to the cost of loosing a group 
            in a tree the score-difference for the tree itself (=more 
            accurate; default is more conservative).  Using '!!' instead 
            of just '!', no groups in reference tree are collapsed. 
      :T/P  use a quick approximation to calculate the value of suboptimal 
            needed to collapse all groups in tree T, or all the groups 
            except a proportion P of the best supported groups, from branch 
            lengths (support can't be larger than branch lengths, under 
            equal weights; under implied weights, the increase in character 
            score collapsing the branch can be calculated).  This will 
            often understimate the value of suboptimal needed, but if no 
            wildcard taxa are present, only by a relatively small factor. 
            In the case of extended implied weighting or auto-weighted opti- 
            mization, it approximates the values with standard implied  
            weights. This is meant to facilitate subsequent use of the  
            "!" option of bsupport (N.B.: not advised for setting value 
            of suboptimal for searches!). 
      &X    combine absolute (A) and relative (R) bremer supports, 
            to approximate results of jackknifing with P(del)=X, with 
            S = ( R x (1-X) ) ^ ( 1/A ).  Default X is 0.36. In the 
            case of implied weights, S = ( R x (1-X) ) ^ ( Wo/A ),  
            Wo=cost of adding a step to a character with no homoplasy, 
            which takes into account that (under implied weights) it is 
            possible that A < 1.  You can also divide A by a factor, 
            F, making the supports lower as F increases (or higher, 
            closer to 100% as F approaches 0), with &X*F. 
      |x    combine A and R, as in "&", but using the formula 
            S = 1 - ( 1 - ( R x X ) ) ^ A, which for some datasets 
            produces a closer correspondence to jackknife values 
            Factors for implied weighting are the same (dividing A), 
            and factor F also divides A (so that the larger F, the  
            lower the support) 
 
CCODE
    !  re-sets ccode to the one defined in the data file 
    Other than that, sets character codes.  Specifiers are: 
         +    make following character(s) additive 
         -     "      "         "        non-additive 
         [     "      "         "        active 
         ]     "      "         "        inactive 
         (     "      "         "        Sankoff 
         )     "      "         "        non-Sankoff 
         ~     "      "         "        semi-additive 
              The ~ symbol (ASCII 126) makes a character Sankoff,  
              with costs between adjacent states unity, between  
              non-adjacent states 2 (see Goloboff et al. 2021, 
              doi 10.1111/cla.12456). This preserves the 
              hierarchy of the character, but without giving 
              large "jumps" too large costs. This can also 
              be done with the "cstree" command. 
         /N   apply weight N to following character(s) 
         =N   apply N additional steps to following character(s) 
              (N.B. internal steps are always 0 for landmark 
               characters, and can't be changed) 
         *    disable all previous specifiers 
 
CDIR
       change directory 
 
CHANGE
    L/N/X Y ;   report min-max. changes from state(s) X to state(s) Y 
                for tree(s) L, char(s). N.  Can use names or numbers, and 
                enclose multiple states/names in brackets. From 01 to 23 
                counts all changes from either 0 or 1 to either 2 or 3. 
    [ L/N/X Y   same, but displays min/max. changes tree by tree 
    ] L/N/X Y   same, but displays results character by character 
 
CHKMOVES
    Check moves that produce trees of equal score (or within specified 
    suboptimal difference), and report number of moves for each node. 
    This helps to quickly identify taxa that decrease resolution of the 
    consensus (or supports). 
    Arguments:  
         [    sort by distance, instead of number of moves 
         &    sort by rerooting depth 
         *    don't list or sort, just show moves on tree diagram 
    Options [, & or * can be followed by list of trees to process 
    (default=all), and this can be followed by the minimum value to 
    report (as /N; this is optional; default minimum is 1). Alterna- 
    tively, use "\N" instead of "/N" to indicate number of  
    distinct values to be printed (i.e. best, best two, etc.) The 
    list (or the specification for the minimum value) can be followed 
    by ">N" (or "<N"), where N is the number of group to which 
    the taxa with value equal or greater than the minimum will be  
    added (or removed from).  In the case of internal nodes, all the 
    descendants of the node are added to (removed from) the group  
    specified. Note that when sorting by rerooting depth, the taxa  
    that belong to the rerooted clade are added/removed.  If macro 
    is ON, then using "=A" will store in array of name/number A, 
    the number/distance/depth for each node of the tree (a single tree 
    must be specified in this case); this can be used together with  
    ">N" or "<N". 
 
CHOMO
    N    show homoplasy (=extra steps) for tree(s) N 
    !N   same, with polytomies as "soft" 
 
CKEEP
         set current ccode as default 
 
CLS
    Clear screen 
 
CLBUFFER
    ;      clear text buffer 
    *     clear command buffer 
 
CNAMES
    Name character(s), state(s), or data blocks:  
    cname 
        {N1 charname state0 state1 state2 ... stateN ;  
        {N2 charname state0 state1 state2 ... stateN ;  
        {N3 charname state0 state1 state2 ... stateN ;  
        ; 
    Use '[' instead of '{' to name data blocks instead of  
    characters. N.B.: when a character is a landmark configuration 
    state0 through N in the preceding example are names of  
    individual landmarks (=points). 
    Other options: 
      *    save character names 
      !    save character names (active chars. only) 
      <    undefine all character (and block) names 
      +N   rename char. N: charname state0 ... n 
      =    when outputting character lists, use name(s) instead 
           of numbers. 
      -    when outputting character lists, use numbers(s) instead 
           of names (=default). 
      &    as some TNT routines (e.g. comparison of datasets, dcomp  
           command) require that all characters be named, this 
           automatically names all characters (with character 
           number C being named/renamed as "nC"). 
      |    use this to convert Nexus format names (e.g. under 
           CHARSTATELABELS) into TNT format. Syntax is:  
               cnames | Nexus-file-name TNT-file-name 
           The TNT file should be ready to be parsed with TNT. If 
           name of Nexus file preceded by "-", it subtracts one 
           from each character number. 
 
COLLAPSE
    N;   set level of tree-collapsing to N 
           0   no collapsing 
           1   if some optimization implies support, keep branch ("rule 3") 
               (this is the default in PAUP*) 
           2   if ancestor and descendant state sets differ, keep branch 
               (this is equivalent to "amb-" of Nona/Pee-Wee) 
           3   collapse branch if some optimization lacks support 
               (this is the default of Nona/Pee-Wee: "rule 1") 
           4   rule 4 of Coddington and Scharff 
           5   Collapse using SPR 
           6   Collapse using TBR 
    +    collapse trees temporarily for consensus calculations (default) 
    -    don't 
    [    after a search, automatically condense trees 
    ]    don't ( default) 
    Alternatively, the options can be given as strings: none, rule 1, amb, 
    rule 3, rule 4 , spr, tbr, [no]auto, [no]tempcollapse. 
    Note that landmark characters are optimized with unique optimal positions, 
    such that ambiguity may go undetected and thus there is no difference 
    for the landmark characters among rules 1 to 4 (i.e. a branch is considered 
    "supported" if some landmark differs in position between node and ancestor). 
 
COMCOMP
    Calculate combinable component (=Bremer ) consensus tree 
    N/L    display consensus for tree(s) N, excluding taxon (taxa) L 
    *N/L   same, but keep consensus as last tree in memory 
 
CONDENSE
    N    collapse branches for tree(s) N, according to settings of "collapse". 
    [N   same, reinforcing constraints of monophyly (i.e. keeping constrained 
         groups, even if unsupported). 
    N/L  collapse branches for tree(s) N, ignoring taxa L. 
    /T N collapse set of node(s) N, for tree T.  Using "*" instead of T, 
         it collapses nodes of tag-tree (retaining the rest of labels); if 
         "=xxx;" is used instead of a node list, then it collapses all 
         the internal nodes labeled as "xxx"; if "<N", then all internal 
         nodes with tag less than N (likewise for ">" instead of "<"). 
 
CONSTRAIN
    =   Re-inforce constraints for mono- and non-monophyly 
    -   don't (default) 
 
COSTS
    N = x>y z  Define transformation costs for character(s) N to be z from all 
               states in x to all states in y.  Can use square brackets to 
               enclose multiple states (e.g. [012]>3 is from either 0 or 1 or 
               2 to 3).  Using / instead of > defines costs as symmetrical. 
               The symbol ? means every possible state. 
       *       save all costs. 
       -       save costs, for active chars. only. 
       [       save costs in TNT format (default) 
       ]       save costs in SPA format 
       <       don't allow using sankoff (saves memory) 
       >       allow using it (=default) 
       &       with asymmetric Sankoff characters, relative fit difference 
               between original and rearranged tree during TBR (to collapse 
               trees, or to estimate relative or combined bremer suports) is 
               by default calculated only approximately. With the "cost&;" 
               option, relative fit difference is (possible bugs aside) 
               calculated exactly. This may use a little more RAM (specially 
               if implied weights is off) and a little more time. 
       |       reset calculation of relative fit differences during TBR  
               swapping to approximate (=default). 
 
CSCORES
    N/L   report length/fit for character(s) L on tree(s) N 
    !N/L  same, optimizing polytomies as "soft" 
 
CSTREE
    N = [cst]  read character state tree (=costs) for char(s) N. 
               Type cst after a carriage return, with symbols /\-| and X. 
    N <C [cst] same as '=', but change all costs larger than C to be C 
               This serves for a "semi-additive" treatment of characters 
               (see Goloboff et al. 2021, doi 10.1111/cla.12456). In the  
               case of lineal additive characters, it can also be done more 
               easily with "ccode ~" (but "ccode ~" does not apply to 
               branching additive characters). 
    +;         optimize character state trees by decomposing them in binary 
               variables; this is faster, and means that under implied weights 
               the fit for the character is the sum of the fits of the  
               individual variables. 
    -;         optimize character state trees as wholes; under implied weights, 
               the fit for the character is calculated using the homoplasy for 
               the entire character, which may differ from the "+" option. 
 
DCOMP
    Compares and combines data from two files; if trees provided (within each file, 
    as a "tread"), then also compares character scores to help determine which  
    characters are responsible for the difference in results 
    Usage:
 
         dcomp outfile data1 data2 [ namefile ]
 
    where "outfile" contains the combined results, "data1" is the newest  
    dataset, and "data2" is the oldest dataset. If settings or cell entries 
    differ in both datasets, "outfile" will contain the options corresponding  
    to the newest dataset "data1", except for taxa/characters present in 
    "data2" but not "data1" (including resolution of missing entries; this 
    can be changed so that program either queries or chooses "data2", see 
    below). The third file name, "namefile", is optional; it should contain 
    a list of taxon names (full names, case, with the name corresponding to  
    data1, if not spelled the same in data2), to be eliminated from consensus 
    and tree comparisons (this is useful when wildcards obscure comparisons). 
      In the combined dataset, the characters unique to "data1" and "data2"  
    are placed in character groups 0 and 1 (named "Unique_to_filename").  
    If trees are included in the data files, then the same thing is done for  
    taxa. Note that the numbering in both cases corresponds to the numbering 
    in the combined dataset ("outfile"); the numbering of the taxa/characters 
    may have differed in the individual datasets being compared/combined. 
      Name of output file can be preceded by: 
      !        don't use Needleman-Wunsch for string comparisons 
      -        do not compare state names to establish character identity (i.e. 
               use only the name of the character itself) 
      +        on the tree topologies provided in each file, place the taxa 
               exclusive to the other file in their best possible locations 
               (on the basis of shared characters).  If using "++", then  
               the taxa are kept for consensus calculations (else, only for  
               character scores). 
      ]        skip creation of image files (*.svg), only producing combination 
               and statistics. 
      <        do not show characters with different lengths on trees for both 
               datasets. 
      >        report scoring differences, per character and per taxon (this 
               considers only discrete characters) 
      /n       action for showing critical cells, identified on the basis of  
               synapomorphies (1), tree-length differences (2), or either (3, 
               default).  Use n=0 for none, and n=4 to report only those changes 
               that are identified by both methods (1) and (2).  
      *        to query matrix differences, ask taxon by taxon, instead of the  
               (default) character by character. 
      &N       use TBR-swapping to estimate differences in combined bremer support, 
               for each of the characters changing cells/settings between the two 
               matrices.  For each character, the difference in support is reported 
               first for the character changing from oldest to newest dataset first, 
               then for the character changing last.  These differences are without 
               including in the matrix the taxa present in newest but not oldest. 
               The last row reports the change in support when adding each of the 
               taxa present in newest but not oldest (one at a time).  The number 
               is the minimum difference in combined bremer support to report a 
               change (0<=N<=100; default N=5; use N=0 to report influence of all 
               character/taxon changes. Keep in mind that this is estimated quickly 
               (by means of a single round of TBR), so that it is only a rough 
               approximation to the difference in supports. 
      |        like "&", but displays results in the form of a table. 
      :X name  save in array named "name" lists of correspondences for taxa or  
               characters. "X" is a two-letter code, which must include either 
               't' (taxa) or 'c' (characters), and either 's' (correspondences of 
               matched taxa/characters, for 's'hared), or 'm' (closest 'm'atches  
               for unmatched taxa/characters).  The array must contain at least as  
               many cells as the number of taxa/characters in the first matrix.  
               After running, the value of cell N in the array will contain the  
               number of the taxon/character of the second matrix that matches  
               element number N in the first. Cells with a value of -1 indicate a  
               non-match (for 's'), or a non-approximate match (for 'm').  The  
               list of correspondences for taxa/characters in the _second_ matrix,  
               if needed, can be reconstructed from the list produced by "dcomp". 
    Default action for combination is 'y', but can be indicated within parentheses, 
    either for a specific query, or all queries (if not preceded by letter code(s)): 
      (tcsdmoaql ynbi?) 
       t      taxa; ask ('?') whether similarly named taxa are the same ('y' or 'n'); 
              if using '!', names must be identical (no taxon queries in this case). 
       c      characters; if option '-' not used, then state names are expected to 
              match (exactly or approximately, depending on '!') as well; if they 
              don't, query ('?') whether they're the same character ('y' or 'n').  
       s      states; state names must match approximately (default, ask whether  
              similar names correspond to the same state, '?'; or 'y', 'n'), or  
              exactly (when using '!'). 
       d      data; differences in observed entries of matrix cells, for discrete 
              characters.  Query ('?') whether states of first matrix should be used ('y'),  
              second ('n'), or both ('b', as a polymorphism).  If several differences 
              exist for the current character (or taxon), then you can also answer 
              'a' (accept all), or 'r' (reject all). 
       m      replace missing with observed entries ('y'), don't ('n').  Default is 
              treating missing entries as other scores ('i', ignore). 
       o      when options (=settings) for characters (additivity, weights, sankoff) 
              different, query for preserving settings of first ('y') or second ('n')  
              matrix. 
       a      if state sequence in additive characters different, preserve sequence in 
              first file ('y'), or use sequence in second ('n').  Note that sequence 
              may be shifted (without altering it) by adding states at the beginning or 
              the end. 
       q      action for quantitative (=continuous) characters.  These are usually scaled,  
              so that a different scaling for the same character can produce differences 
              in the two matrices; dcomp takes the two most-distant taxa in the first matrix 
              (present also in the second matrix; these are usually the smalles and largest 
              taxa in first matrix, but may not be so in the presence of polymorphisms),  
              and rescales both characters to the same range; if the rest of the taxa become 
              identical, then the two characters are merged on that scale; if less than  
              20% of the taxa have differences, then user is queried for merging characters 
              on the common scale using values of first matrix ('y'), second ('n'), or the 
              range encompassing both matrices ('b').  If more than 20% of taxa are different 
              after common rescaling on those two shared taxa, then missing entries in first 
              matrix are retained as missing entries (no questions asked). 
       l      action for landmark characters (=configurations); if a taxon is scored for the 
              configuration in both matrices and the landmark coordinates are similar  
              (with a sum of lineal distances between configurations below 10^-4), nothing 
              is done; otherwise, configuration in the second matrix is sized, shifted,  
              and rotated against first; if this still results in different configurations, 
              then a query is issued for retaining coordinates in first matrix ('y') or  
              using instead the coordinates for the second ('n'). 
    Inside the parentheses, use ">storefile" (or "<storefile") to create (or read from)  
    a file storing all the decisions.  This requires that the same options (and input files) 
    be used. An output "storefile" interrupted (with <esc>) subsequently used as input 
    "storefile" returns control to user when reaching end of instructions.  Both an output 
    and input storefile can be indicated in this case, so as to complete the output storefile 
    with the decisions not yet stored in the input storefile. 
      Also, inside the parentheses you can include a letter 'f' ('f'orced matches) followed  
    by a filename, containing pairs of matches (number in first dataset, number in second  
    dataset), for taxa and characters (each list of pairs preceded by "*taxa" or  
    "*characters").  This forces the specified pairings between taxa/characters, regardless 
    of names.  Separating the pair of numbers by '!', the two taxa/characters (even if named 
    identically) are forced to be different (and, in the case of taxa, appended "_A" and 
    "_B", to make multiblock matrices readable). 
      Note that this ("dcomp") is also a scripting expression, returning the numbers of 
    differences between the two input datasets. 
      The results of the comparisons are (by default) saved as image (SVG) files, showing 
    synapomorphies for groups present in one of the data files but not the other, and 
    viceversa, as well as a colored diagram ("matrix_differences.svg") to show differences. 
 
DMERGE
    dmerge     merges files; syntax is:  
                    dmerge OUT =DIR IN1 IN2 ... INn 
               merges files IN1 to INn (from directory 
               "DIR", optional) into file "OUT".  If  
               name of outfile preceded by "|", then it  
               treats input files as TPS (=landmark) files. 
    dmerge*;   merges characters with identical names 
 
DRIFT
    Do tree-drifting, from trees in memory.  Options are: 
      iterations         number of cycles (=iterations) to do 
      numsubs N          number of replacements (i.e. accepted tree 
                         rearrangements) to do in perturbation phase 
      xfactor N          larger values make acceptance of suboptimal 
                         trees less likely 
      [no]autoconst N    number of constrained cycles 
      [no]giveup N       max. percentage of full swap to do in perturbation 
                         phase.  This is an int, so 99 means don't give up 
      fitdiff            max. difference in absolute fit 
      rfitdiff           max. difference in relative fit 
      findscore N        stop drifting when score N hit 
      [no]equals         alternate perturbed and unperturbed drift cycles 
                         (note: for landmark data, unperturbed cycles are  
                          never done). 
      [no]fuse NxR       every N iterations, do R rounds of fusing to the 
                         N trees 
      [no]dumpfuse       if fusing fails to produce a better tree, [don't] 
                         dump all the suboptimal trees 
      flat N             run the first N iterations using the relative 
                         fit difference defined with rflat 
      rflat N            max. difference in relative fit difference  
                         for initial iterations 
      flatnumsubs N      number of replacements to do for initial iterations 
      [no]pert           never accept suboptimal rearrangements (i.e. "drift" 
                         only wanders around in the island; this does force 
                         unperturbed cycles in the case of landmark data). 
    Options set with "drift:[options];" or "drift=[options];" (first  
    case changes settings only, second case runs). Using "drift:;" current 
    settings are displayed 
 
EDIT
    X Y   edit node Y of tree X.  Then, J L sends J to node L.  If J is an  
          ancestor of L, reroots clade J on L. /N collapses node N (this 
          can be given as a list, with nodes separated by '+'). 
    ]     do the changes in silent mode. 
 
ECHO
    =   echo each command 
    -   don't echo 
    [   if log file opened and taking commands from console, 
        echo console input to log file 
    ]   don't 
 
EXPORT
    export data in NEXUS format.  If filename followed by "+", 
    copies everything to the end of the NEXUS file, until a semi- 
    colon is found (use it to embed PAUP* or TNT commands in 
    the file).  TNT commands can be included at the end of the 
    file, preceded by "begin tnt." 
    Possible arguments (before file name): 
        *     trees as well 
        +     step-matrices as well 
        -     trees only (including tree-tags, if defined) 
        >     tree-tags only, as branch lengths 
        <     tree-tags only, as branch labels 
        [     save as dna 
        ]     save as standard 
        !     save as Fasta instead of Nexus (!! skips gaps) 
        =     save trees only, pure Newick 
        |     save in TPS format.  Syntax is:  
                export | filename C T ;  
              this saves to file character (=landmark  
              configuration), including ancestral states 
              for tree T (only if T, optional, is specified). 
 
EXIT
       ditto! 
 
FIT
    N   report total fit, for tree(s) N.  It is measured with a convex 
        increasing function, to be minimized 
    !N  same, optimizing polytomies as "soft" 
    *N  report total fit (measured with a concave decreasing function, to  
        be maximized; the equivalent of what PAUP* and Pee-Wee report) 
 
FILLSANK
    =   complete polymorphic cells for Sankoff characters 
    -   don't (default) 
 
FORCE
    ;   report present constraints 
    ]   de-activate constraints 
    =   followed by a tree, use groups in tree (&N uses tree N) 
    /   followed by a tree, use tree as skeleton tree (&N uses tree N) 
        (if outgroup is excluded, it acts as a "convexity" constraint) 
    :   same as /, but for negative constraints 
    +   positive constraints: [ a b c  (d e) ] ( taxa d and e float; 
        if outgroup is floating, acts as a "convexity" constraint) 
    -   same as +, but negative 
    >N  taxon(taxa) N floating for all positive constraints 
    <N  same, for all negative constraints 
    *   report number corresponding to each constraint 
 
FREQDIFS
    Calculate frequency difference tree (FDT) 
    =N      use N as cutoff 
    N/L     display FDT for tree(s) N, excluding taxon (taxa) L 
    [J]N/L  calculate frequency differences for each group of 
            tree J, on tree(s) N, pruning taxon (taxa) L 
    (J)N/L  same, but display results as table 
    *N/L    same, but keep FDT as last tree in memory 
    &N/L    show and save FDT as last tree in memory 
 
HELP
    ;     display list of commands 
    *     display options for all commands 
    xxx   display options for command xxx (equivalent to xxx ?) 
    !N    when parsing names for commands, taxa, or other, 
          check for typing errors (N = max. string similarity, 
          default = 0.75), with a Needleman-Wunsch algorithm. 
    >N    like previous one, but also applies Needleman-Wunsch 
          to options (strings) within commands. 
    <     no Needleman-Wunsch for name matching. 
 
HOLD
    N     set tree buffer to keep up to N trees 
    +N    increase max. trees to number of trees in memory + N (++ = 1 ) 
    -N    decrease max. trees to number of trees in memory - N (-- = 1 ) 
    N/V   set a "tree-vault" in internal memory, where trees can be 
          placed to be protected from other commands (e.g. search commands) 
          This sets max. trees to be N, vault size to be V.  Trees can  
          be placed in the vault, or retrieved, with the "tvault" command. 
          Subsequent execution of the "hold" command  (other than the  
          default ';') resets the vault (discarding trees from the vault). 
          Using "+V"or "-V", it sets the size of the vault to the 
          number of trees in memory plus V, or minus V, respetively. 
 
HYBRID
    hybridize/complete trees.  This exchanges non-identical groups 
    pruning unshared taxa, so that resulting tree is incomplete. 
    This is meant to be used in cases where tree-fusing (which 
    exchanges only identical groups) cannot improve the tree, 
    by virtue of the trees being too different (i.e. very poorly 
    structured data), but it outperforms tree-fusing rarely. 
    X Y/Z   exchange a chunk (with no more than Z unshared taxa) 
            between trees X and Y, then complete trees and swap. 
            Note that X Y may be a scope (or a tree-group) containing 
            two trees. 
    -X Y/Z  same, but don't complete or swap trees 
    +N      if tree N is incomplete, sequentially add missing taxa 
    *N      same, but also swap (TBR, nomulpars) 
 
IENUM
    Do implicit enumeration (=results guaranteed to be optimal; 
    feasible only for small data sets) 
    Options:  
       &      when there are N most parsimonious trees, but maxtrees 
              is set to a smaller number, take a (pseudo)random sample 
              of the N trees, such that each tree has a prob. of about 
              maxtrees/N to be sampled. Works better as maxtrees/N is 
              closer to 1. 
       -      deactivate a bounding method speeding up many well- 
              structured data sets (usually produces slower searches) 
 
INCLTAX
    [N   report which taxa are included in tree(s) N (default) 
    ]N   report which taxa are excluded from tree(s) N 
 
INFO
    +   report which character(s) are informative (default) 
    -     "      "        "       are uninformative 
 
LOG
    xxx   open log file xxx (use "stdout" if redirecting output) 
    +xxx  open in append mode 
    /     close current log file 
 
LINTREES
    =    draw trees in Linux format (default) 
    -    don't 
    *    use command-recalling 
 
KEEP
    N   keep no more than N trees, discard the rest 
 
KLEEX
    Calculate clique (=compatibility) trees, using James 
    S. Farris' fast implementation of Bron-Kerbosch's  
    algorithm for maximal cliques.  Applicable only to  
    binary data with no missing entries.  It is an exact  
    enumeration of all maximal cliques, and thus not  
    practical (or applicable) to too large inputs. Useful 
    for purposes of comparison (e.g. with TNT's algorithms 
    for heuristic searches). 
 
LENGTH
    N   report total length, for tree(s) N 
    !N  same, optimizing polytomies as "soft" 
 
LIK
      T/C  Calculate likelihood (single rate, jukes-cantor only) for 
           tree(s) T and character(s) C.  Settings with "lset". 
 
LMARK
    Map and handle settings for 2D and 3D data (landmarks) 
    Options:  
      ambig         specify which points to choose in the case of ambiguity  
                    (rarely needed, as ambiguity is uncommon).  Examples:  
                       ambig YxZ C  chooses maximum y first, if ambiguity 
                                    remains minimum x, and if ambiguity remains 
                                    maximum z (ambiguities in unspecified 
                                    coordinates are solved randomly), for 
                                    character(s) C. 
                       ambig * C    choose randomly (=default). 
                       ambig ;      display current setting. 
      cells N       divide grid in N cells 
     [no]confsample when calculating relative bremer supports or resampling, 
                    sample entire configurations (no=individual landmarks). 
      connect       define connections between points for display. Format is: 
                        lmark connect C La-Lb Ld-Le Ld-La ; 
                    this defines lines ("wireframes") from landmark A to B, 
                    D to E, and D to A, for configuration C.  This is used 
                    only for diagrams; it does not affect any calculation. To 
                    specify connections for more configurations, separate the 
                    specifications for each configuration with a slash.  Every 
                    time this command is issued, the connections are reset to 
                    the new specification. 
      dims          show a table with dimensions (if continuous, 1; if discrete, 0). 
      errmarg N     during branch-swapping searches, use N% of tolerance above 
                    the score calculated initially with faster shortcuts. Higher 
                    values of N make for safer but slower searches, and viceversa 
                    (default N= 5%). Instead of a number N, symbols "+" or "-" 
                    can be used to turn reports of landmark shortcuts on/off 
                    (respectively) during "mult" or "bbreak" searches.  Note 
                    that the actual error is calculated on cases evaluated with 
                    a full optimization, the number of which may in turn depend on 
                    the error margin set by the user. 
                    Alternatively, it is possible to specify an error margin that 
                    varies during the search, so that it is low in the initial stages 
                    (where better trees are easily found) and stricter at the end 
                    (where you want to make sure that no better trees in the TBR or 
                    SPR vicinity are missed because of miscalculations).  You can  
                    specify between 2 and 6 stages of error.  The syntax is:
 
                          lmark errmarg A-B-D/X-Y-Z
 
                    this will use error margin 0 until X% of the clippings to complete 
                    swapping have been effected, error margin A between X and Y of the 
                    swappings, error B between Y and Z of the swapping, and error D 
                    at the final stage (after Z% of swapping completed). To specify 
                    only two stages you would do:
  
                          lmark errmarg A/X
 
                    which will use error margin 0 from start to X% of swapping, and 
                    then error margin A. 
                    If the last error margin (e.g. D in the first example) is followed 
                    by "<N", then the last error margin will be the smallest of D and 
                    the error observed up to that stage of the calculations plus N 
                    standard deviations; likewise for ">N".  This is a way to let 
                    the eror margin be determined, to some extent, by the data at  
                    hand (N.B.: the observed error continues being calculated after 
                    switching to the final error margin, so the report may be different 
                    from the final error used).  When this option is in effect, the  
                    search status report informs the current error margin (as "em"). 
                    The variable error margins are used during the initial stages of  
                    multiple random addition sequences (with "mult" or "xmult") as  
                    well as after rebuilding a tree with the commands "hybrid" 
                     or "rebuild". 
      factors       define factors for the individual landmarks.  These are then 
                    used *instead* of the factors determined automatically. 
                    Syntax is:  factors =F C/L, which uses factor F for character(s) 
                    C, landmark(s) L (if no C or L specified, it's all C or L;  
                    if F is "*" then automatic factors are used for C/L). 
                    Note: factors are used only when implied weighting is off! 
                    With implied weighting OFF, factors multiply the score. 
                    With implied weighting ON, factors are always unity. 
     [no]inscale   [don't] weight individual landmarks so that the contribution 
                    of each landmark within a character is similar (i.e. give 
                    landmarks with a larger range a lower weight) (default = don't). 
                    Note that any of the two choices makes the contribution of a 
                    landmark character (unless modified with "lmark wts") similar 
                    to that of a step in a discrete character, by weighting based 
                    on the range of the landmarks and the number of landmarks. 
     [no]iter       in addition to sankoff approximation, iterate exact calculation 
                    of geometric medians.  For dichotomies, this uses an exact 
                    solution for the Fermat point (ancestor-left-right descendant), 
                    with functions written by S. Catalano with collaboration from 
                    P. Goloboff.  For polytomies, a heuristic approximation of 
                    the geometric median is used. 
      list          list character types.  Default is listing dimensionality of 
                    each character.  List - lists only one-dimensional characters; 
                    list + does the opossite; list N lists all characters of N 
                    dimensions. 
     [no]lowmem     use low memory calculations (possibly slower) 
      lscores N/C/L report individual landmark scores in tree(s) N, character(s) 
                    C, landmark(s) L (default=all).  List L can contain landmark 
                    names (if defined) only if list C contains a single character, 
      map N/C       map character(s) C on tree(s) N 
      maxiters N C  iterate up to N times, cut when improvement below C 
      maxpoints N   Prior to reading data, set the maximum number of landmarks 
                    (=points) per configuration to be read. This is the only option 
                    of "lmark" that can (must) be used prior to reading data. 
      maxprec N     skip characters with range (max. dist) below N 
      multimap      show ambiguity in point mapping.  Syntax is :  
                        multimap R T C L 
                    where R=replications, T=tree, C=character, and L=landmark. 
                    Variability indicates either ambiguity in optimization (if 
                    settings exhaustive) or errors in optimization algorithms 
                    (if settings superficial). 
      nest N W      nest sankoff approximation N times, with a Window of W cells 
      numlands      display a table with number of landmarks in each configuration 
      option        display all current settings for landmark optimization 
      precision     report expected precision of individual points under sankoff 
                    approximation 
     [no]quickwag   after adding each taxon in a Wagner, recalculate position for  
                    each point from scratch (instead of using Farris's 1970 "median 
                    method").  This is much slower, and does not add much precision 
                    --incomplete taxon subsets are more influential than errors in 
                    point locations.  This is not recommended, included only as a 
                    way to test the accuracy of the "median" method. 
      refine BxR    during branch-swapping searches using an error margin, refine 
                    ancestral point positions for trees that are near-to-acceptable, 
                    by incrementally re-calculating fermat points away from union 
                    node, up to B branches away from union, with up to R rounds of 
                    refinement (default=don't). 
      rescale       multiply each value by a factor.  Note this modifies the matrix 
                    in memory.  Syntax is:  
                        rescale =F C/L  
                    where F=factor (if F is "*", then it uses current factors for 
                    each landmark), C=character(s), L=landmark(s). 
      shake N       in first sankoff approximation, slightly distort grid N times 
     [no]showhtus  [don't] show HTU's coordinates after mapping (default = don't) 
     [no]shrink     shrink grid if there are outliers (useful for low cell values, 
                    8 or less, probably won't help for cells > 10). 
      swap XY       swap values of XY (or XZ, YZ) 
     [no]skip       during the first sankoff approximation, try to quickly identify 
                    cells not needed (may save some time). 
     [no]termpoints make sure the first Sankoff matrix contains terminal points. 
                    With "termpoints -" no grid is used, only the points of terminal 
                    taxa; "termpoints +" reconnects the use of grid. 
      threads N     to optimize landmarks during searches, use N threads. Default N is 
                    number of processors. This is a simple parallelization, for exact 
                    score checks during searches. The time it saves depends on how  
                    much time the Sankoff approximation uses. Thus, it saves more 
                    time for larger numbers of taxa, larger number of grid cells, low  
                    memory algorithms, more rounds of nest and shake, and for 3d  
                    instead of 2d landmarks. Use "threads 0" to run serially (i.e. 
                    on a single processor). Use "thread *" to set automatically to 
                    number of processors. 
      usmin         set (or display) current minima for implied weighting.  Default 
                    is maximum span of Steiner tree for any triplet of taxa.  This 
                    quickly sets an upper bound for the actual minimum, but may 
                    overestimate it.  The user can set a different value (e.g. with a 
                    search for each individual landmark).  Syntax is: 
                        usmin =M C/L  
                    where M=minimum, C=character(s), L=landmark(s).  If M is "*", 
                    then it uses default; this is quick but will generally underes- 
                    timate minimum, so that homoplasy is overestimated and implied  
                    weights underestimated.  Using "!" instead of "*" will build 
                    a Wagner tree plus TBR on the specified landmarks, then using 
                    the resulting values as user-set minimum values.  This is  
                    obviously much more time consuming (you may save the resulting 
                    values to a log file for subsequent input, so that minimum doesn't 
                    need to be recalculated again).  For 2D data, just one Wagner and 
                    TBR usually converges onto actual minimum for most settings of cell 
                    number and error margin; convergence for 3D data seems to be not as 
                    common.  The values obtained are the same as the scores you would 
                    obtain if setting implied weights off, the weights (wts) for all 
                    but the landmark of interest to 0 (and the weight of the landmark 
                    of interest to 1), and the factor to unity; in this way you can 
                    perform searches more exhaustive than just a Wagner+TBR.  Note 
                    that a user minimum larger than the actual one will underestimate 
                    the amounts of homoplasy and overestimate implied weights (and 
                    if detected during a run, corrected). 
                    With  
                        usmin =(T) C/L  
                    instead of a search, the values for the landmarks specified are 
                    taken by optimizing tree T in memory. If tree T is of minimum  
                    length for configuration C, this can be used to set minima for  
                    (implied) weighting of configurations on the basis of the  
                    homoplasy of the entire configuration (this must be used together 
                    with "xpiwe" and a weighting-set for each configuration). 
      wts           define weights for the individual landmarks.  These are then 
                    *combined* with the factors determined automatically. 
                    Syntax is:  wts =W C/L   which gives weight W to character(s) 
                    C, landmark(s) L (if no C or L specified, it's all C or L;  
                    if W is "*" then unit weights are used for C/L). These weights 
                    affect the scores under implied weighting, except for those 
                    landmark characters which are part of a weighting-set (see 
                    under "xpiwe"); in that case, those individual landmarks are 
                    always weighted equally within the set. 
     [no]xthread    Handle whether multiple threads for tree-searches are left  
                    always waiting ("xthread"), or they go up/down for each 
                    search ("noxthread"). This can be useful in case you are  
                    planning to do very large numbers of searches and your system 
                    has a limit on the number of threads that a program can initiate 
                    (i.e. very special circumstances). 
 
LMBOX
    Save landmark box(es) to the specified SVG file.  The SVG extension should be 
    specified; this image file can be opened with any web browser. 
    Syntax: 
 
        lmbox filename T C = L; 
 
    where T tree number, C character number, and L list of taxa (either terminals 
    or internal nodes). 
    The displaying of lines, landmark numbers, or other parameters can be specified 
    before the "=" symbol:
 
       line +cgfplnsdo turn ON the display of each option (with '-' instead of '+',  
                       turn OFF); options: c connectors, g grid lines, f frame  
                       p apomorphic displacements, l lines, n landmark numbers,  
                       s user defined lines, d descendants, o overlap ancestors.  
       tilt F-L/N      set tilt (3d only); this displays N boxes, the first with  
                       tilt F, the last with L, increasing by (L-F)/N every time. 
       rot F-L/N       set rotation (3d only); this displays N boxes, the first with  
                       rot F, the last with L, increasing by (L-F)/N every time. 
       size N          draw boxes of size N (default=120); points and lines become 
                       proportionally smaller/thinner as box size increases 
       [no]bw          [do not] draw boxes in black and white (default = color) 
       [no]color       [do not] draw boxes in color 
       bigframe        for 2D only, expand the frame so that all points lie inside 
 
LMREALIGN
    Realign specified landmark configurations (=characters) 
    Keep in mind that the realignment modifies the matrix held in memory, 
    so that it is not possible to go back to the original coordinates 
    except by re-reading the data file. 
    Twopoint (p1 p2)/C  align character(s) C using baseline registration  
                        considering landmarks p1 and p2 as reference. Valid  
                        only for 2D characters. 
    Rftra  [N]/C        align character(s) C in all taxa against taxon N  
                        using a repeated medians procedure (Siegel & Benson 1982). 
                        Valid only for 2D characters. 
    Pairlin [N]/C       align character(s) C in all taxa against taxon N  
                        minimizing the sum of linear distances. 
    Tree T cycles Y level L/C  align character C on tree T using a tree-based  
                        alignment with parsimony as optimality criterion 
                        (Catalano & Goloboff 2012) 
                        Y= number of cycles of improvement/perturbation. 
                        L= thoroughness in improvement step (0-4). 
    Random N            rotate/translate all configurations at random. Does N 
                        cycles of random changes to  the alignment.  Useful for 
                        exploring the data and the effectiveness of alignment 
                        algorithms. 
        !               Adjust size as well (valid only for Rftra and Pairlin) 
    The "pairlin", and "tree" options take into consideration the weights  
    defined by the user for each landmark (with lmark wts). This allows  
    aligning by considering specific landmarks (e.g. giving zero weight to  
    the rest of the landmarks 
    NOTE: the code for aligning was written by Santiago A. Catalano in  
    collaboration with P. Goloboff. 
 
LQUOTE
    =      set literal quotes on (see "quote") 
    -      set literal quotes off (see "quote") 
    [      within "quote" read &N as ASCII character N 
           In non-windows version, &0 erases line and 
           places cursor at the beginning ofline, and &1 
           backs-up one space 
    ]      don't 
    >      bounce quotes to stderr (even if in background) 
    <      don't 
 
LSET
    Change settings for likelihood calculations. 
     
    General options: 
     
        passes I E      maximum number of internal/external passes 
        ldelta          delta for likelihood 
        bdelta          delta for individual branches 
       [no]gstatespace  [don't] use the same state space for all characters 
                        (only for morphological data), scripting expressions 
                        implik, simplik, and mklik (default=nogstatespace) 
                        Note that the "nogstatespace" option has the 
                        peculiarity of making invariant characters irrelevant 
                        (transformation can be into a single state, only 
                        possible reconstruction is with that single state at 
                        all nodes, and L=1). 
        display         lik (default), brlen (optional).  This affects the 
                        display of scripting expressions implik, simplik, 
                        and mklik (and only if "report" is ON).  As the 
                        (character) likelihoods or (branch) lengths are 
                        displayed, they can be stored into user variables 
                        for use in scripts, with "maketable". N.B. when 
                        character dependences defined (with "xlinks"), 
                        there is no direct way to calculate the likelihood 
                        of the individual characters; the likelihoods of 
                        the characters in a complex are then the average 
                        (i.e. the log likelihood of the divided by the 
                        number of characters in the complex). 
        speed F         set the initial factor for changing branch lengths 
                        to F. Default F is 0.0666, larger factors change 
                        branch lenghts more drastically (this can be needed 
                        in cases where initial estimation of branch lengths 
                        --via parsimony-- is far off). 
        sprior          set how prior probabilities for states are calculated 
                        Options: "equal", "empirical" (identical for all 
                        characters; PAUP*'s default, but not too meaningful 
                        for Mk model), "individual" (empirical, but done 
                        separately for each character), and "user". For 
                        "user" a list of character numbers followed by 
                        the frequency F of each state, separated by commas: 
     
                            lset sprior user 
                                0 0.1 0.2 0.3 0.4 
                                1 0.5 0.5 
                                2 0.333 0.333 0.333 ; 
     
                        note that as many F values as states in the character 
                        are required (i.e. in the example, character 0 would 
                        have 4 states, character 1 2, and character 2 3). With 
                        a semicolon after "user", current values are saved. 
                        For characters for which no "user" value is specified, 
                        the individual state frequencies are used. 
                          The state priors influence the transition probability; 
                        for individual characters (and thus, for complexes, if 
                        defined); for i->j (where state j has frequency F and 
                        branch has length L) is as in the F81 model: 
                               F+((1-F)/e^L)     when i equals j 
                               F-(F/e^L)         when i different from j 
                        when state priors equal, these become the familiar 
                        Neyman model, where F=1/s (s= number of states). 
       [no]mkv          If dataset contains no invariant characters, apply 
                        correction for ascertainment bias in informative 
                        morphological characters (=Mkv model) [default=no]. 
                        This is applicable only in some contexts (i.e. 
                        global state space, equal state frequencies, and 
                        no character dependences defined). 
        perturb N R     For Mk calculations only, when initializing branch 
                        lengths on the basis of parsimony, randomly increase or 
                        decrease lengths by N percent (depending on random seed), 
                        in R rounds (improves accuracy, takes more time). 
     
    The following options are relevant when character dependences have 
    been defined (with "xlinks") and characters form "complexes": 
     
        rates/probs     Define method for calculating transition probability 
                        when some characters are linked. This can be handled 
                        in two ways: 
     
                        (a) by deducing rates of change between character 
                           state combinations (i.e. as in Tarasov 2023, 
                           doi 10.1093/sysbio/syad005) on the basis of 
                           the character interactions, and then calculating 
                           transition probabilities for a given branch length 
                           by exponentiating the rate matrix, 
                        (b) by approximating the probability of change between 
                           character state combinations as the product of 
                           the probabilities of change of the individual 
                           characters (taking into account interactions, as 
                           in Goloboff et al. 2021, doi 10.1111/cla.12456). 
     
                        Method (b) is only approximate, because in a case 
                        with tail absent/red/blue (A,R,B), and branch with 
                        time t, P(RB,t) is not the same as 
     
                                 P(RA,t/2)*P(AB,t/2) + 
                                 P(RR,t/2)*P(RB,t/2) + 
                                 P(RB,t/2)*P(BB,t/2) 
     
                        thus failing a fundamental property of phylogenetic 
                        Markov assumptions. The implementation of method (b) 
                        is retained to allow testing it, but the method is 
                        not recommended. Method (a) produces proper values 
                        in cases like shown above, and for all cases of 
                        inapplicability; with more complex dependences, 
                        it produces exact values as long as the conditions 
                        are specified with just one statement and every 
                        character appears once in the expression (repeating 
                        characters may produce inaccurate values). With 
                        the optional "noxcovary covary 2", or "noxcovary" 
                        with larger values of "covary" and conditions 
                        not combining OR's and AND's for either parent 
                        or son conditions, the calculations are correct, 
                        but may be inaccurate otherwise. 
        covary N        This option applies only with "lset rates". In 
                        independent characters, the rate for any two 
                        characters changing simultaneously is always 0 
                        (can't change both in an infinitesimally short 
                        period of time). When defining dependences other 
                        than inapplicability, it may be reasonable to 
                        assume that characters can instantaneously change 
                        jointly. E.g. if character 1 can have states 0-2, 
                        but only 1-2 when character 0 has state 1, then 
                        a change 0->1 in the first character may instan- 
                        taneously "drag" character 1 into a different 
                        state if it had 0. The number of co-dependent 
                        characters that can change simultaneously is 
                        by default not limited; this can be changed to 
                        any number N with "covary N": 
     
                              lset covary N = C1 C2 C3 ; 
     
                        different character complexes can have different 
                        numbers of covarying characters (i.e. this may 
                        depend on the strength of the presumed interaction), 
                        but every character in a complex must have the 
                        same maximum number. Recall that (in lists of 
                        characters), expression "^N" indicates "all 
                        the characters in complex N", so that the 
                        maximum number of covarying characters can be set 
                        easily for a given complex N: 
     
                              lset covary X = ^N ; 
     
                        Use N=0, or "nocovary", for all changes to 
                        occur separately. Instead of the hat "^", you 
                        can easily place all the characters of a complex 
                        in character-group G, with "xgroup=0 complex=N", 
                        so that the list uses {G}: 
     
                              xgroup=0 (G) complex=N ; 
                              lset covary X = { G } ; 
     
                          Note that when the dependence is defined via 
                        several separate conditions, or when the condition 
                        involves repetition of the same characters, then 
                        the calculation of the probability of satisfying 
                        the conditions can be calculated only approximate- 
                        ly. Thus, probabilities for 
     
                            xlinks = 0 1 & 1 1 <2 1 | (3 1 & 4 1)> 
     
                        can be calculated correctly, but for 
     
                            xlinks = 0 1 <(1 1 & 2 0) | (1 0 & 2 1)> 
     
                        cannot (the two parts of the son condition refer 
                        to the same characters, even if expressed in 
                        a single condition). 
                          Note that exact probabilities of satisfying 
                        conditions can be calculated exactly (with the 
                        restrictions above) only using substantial amounts 
                        of memory. For large datasets, you may not have 
                        enough RAM to use the exact calculation; in 
                        that case, you can set the calculations to evaluate 
                        changes in conditions one at a time, with "lset 
                        noxcovary". 
        [no]xcovary     Calculate the exact probabilities of satisfying 
                        conditions of parent/son characters in transitions 
                        between character state combinations (or [don't]). 
                        The default is "xcovary", but this uses substan- 
                        tial amounts of memory. Turning this off still 
                        produces exact calculations when (a) the conditions 
                        are defined using only AND's or only OR's (son 
                        and parent conditions can differ, though), or 
                        (b) at most two characters are allowed to covary 
                        ("lset covary 2"). If neither condition (a) nor 
                        (b) are satisfied, the "noxcovary" option is 
                        only approximate. The approximate nature is 
                        because (with "noxcovary") these probabilities 
                        are precalculated for a single character at a time; 
                        when several characters differ between two 
                        combinations, their product is used. This is not 
                        the actual probability; consider dependences 
                        defined as: 
     
                              xlinks = 0 0 < 1 1 | (2 1 & 3 1)> 
                        or: 
                              "when character 0 has state 1, then 
                              either character 1 must have state 1, 
                              or characters 2 and 3 must have state 1" 
     
                        Thus, for any change from 0,0,0,0 into a 1 for 
                        the first character, then either a change into 
                        1,1,0,0, or into 1,0,1,1, is required. For a 
                        change between combinations 0,0,0,0 into 
                        1,1,0,0 the conditions in the descendant 
                        combination would change from (0|(0&0)) into 
                        (1|(0&0)). Into 1,0,1,1 instead, the condition 
                        would become (0|(1&1)). If any of the characters 
                        can change to satisfy the condition, then it 
                        is twice more likely to fulfill it by changing 
                        1 character than 2, so that the probability of 
                        (1|(0&0)) is 0.6666. For a change into 1,0,1,1, 
                        the probability would be the complement, 
                        0.3333; yet the probability of every change into 
                        1 in characters 2 or 3 is calculated by TNT 
                        individually, not together, as 0.5 (assuming 
                        character 1 is in state 0, and one of 2 or 3 
                        is in 1 already ). The change into 1,0,1,1 
                        is then estimated as the product of these 
                        individual probabilities, 0.25, instead of the 
                        correct 0.3333. This can happen only when 
                        combining AND's and OR's in a condition, and 
                        when more than 2 characters can change jointly. 
        dependence      This option has two different meanings, depending 
                        on whether transition probabilities are calculated 
                        with rates or with products of probabilities, 
                        and depending on the setting of "covary". The 
                        default is "mutual" for all characters, which 
                        can be changed to "directional". This can be 
                        changed on a character-by-character basis, with 
     
                              lset depend directional = C1 C2 C3 ; 
     
                          When using "rates", the "directional" option 
                        means that a parent character changing into the 
                        restricting condition can drag other character(s) 
                        (up to the maximum number of characters allowed 
                        to covary) to change to fulfill the condition in 
                        the son character(s), but a son character cannot 
                        change to cease satisfying the condition imposed 
                        by the parent unless the parent changes first. That 
                        is, parent influences son, but son does not 
                        influence parent. With the "mutual" option, a 
                        son character having a change that makes it cease 
                        to obey the condition imposed by the parent, makes 
                        the parent character to change the characters 
                        required for the parent condition to not longer 
                        apply. That is, son character(s) can influence the 
                        parent character(s). The "mutual" and "directio- 
                        nal" options are relevant only when "covary" is 
                        set to 2 or more (and "covary" determines the 
                        maximum number of son characters that can be 
                        dragged by the parent characters, or parent 
                        characters that can be dragged by the son 
                        characters). 
                          When using "probs", the "directional" option 
                        corrects transition probabilities to (try to) make 
                        the probability of changing from combinations with 
                        the states in the parent character(s) that do not 
                        restrict the states in the son character(s), into 
                        combinations with the restricting states, equal to 
                        the probability of such a change in the parent 
                        character if there was no interaction. This is, 
                        the parent character influences the probability of 
                        change of the son, but not viceversa. In this case, 
                        the prior probabilities of each individual state 
                        in a given combination of states equals the prior 
                        probability in the individual character. 
        xbuff N L         As the repeated exponentiation of the rate 
                        matrix to produce transition probabilities (e.g. 
                        for optimizing branch lengths when calculating 
                        likelihood) is time-consuming, it is possible to 
                        precalculate transition probability matrices for 
                        a number of branch lengths, and then interpolating 
                        for other values between the two closest lengths 
                        stored in memory. This obviously requires substan- 
                        tial amounts of memory. The default uses N=30 
                        matrices, with lengths from 0 to 1.5. The interval 
                        between 0 and the maximum buffered branch length 
                        is divided unevenly, with buffers for shorter 
                        branch lengths spaced closer to each other 
                        (using a hyperbolic function; this is done 
                        because the initial trajectories of the probabi- 
                        lity as a function of branch length are steeper, 
                        so that the uneven branch length intervals are 
                        more evenly spaced on the actual curve of proba- 
                        bility). For branch lengths exceeding the maximum, 
                        the rate matrix is exponentiated. The use of this 
                        shortcut increases speed substantially, with 
                        only a minor decrease in precision. 
        [no]xprecision  When using "xbuffer", try to squeeze a little  
                        more precision from the buffers, without increasing 
                        RAM usage (at a small performance penalty). If you 
                        can use the RAM, you're generally better off  
                        increasing "xbuffer", not "xprecision". Use  
                        just as a last resort. 
        pade/eigen      By default, the exponentiation of the rate matrix 
                        is done by calculating eigen vectors and values 
                        ("lset eigen"). Alternatively, Pade's approxima- 
                        tion can be used; this is slower and less accurate 
                        for long branch lengths. 
                          In complex rate matrices (i.e. where some of the 
                        eigen vectors or values are complex numbers), the  
                        Eigen method used in TNT is inadequate, and then  
                        the program automatically switches to Pade's method 
                        for those character complexes, even if the "eigen" 
                        option is set. 
                          Note that the use of "xbuffer" is independent 
                        of this option (i.e. the multiple precalculated 
                        transition probability matrices can be calculated 
                        either by the Eigen or Pade methods). As Pade's 
                        method is slower, the use of "xbuffer" is even 
                        more important in this case. 
        [no]poorman     When drawing tables for calculation of transition 
                        rates, use poor-man's drawing (=default), or don't 
                        (draw tables with nicer lines). Relevant only for  
                        rate tables (not probability tables). 
        [no]xlimit      when a parent can "covary" with its son(s), then there 
                        is no restriction in the states that a parent can 
                        effectively take --any transition into a state that 
                        enables a rule of dependence will be followed by 
                        concomitant transitions in the dependent characters. 
                        Likewise when a son transitioning into a state that 
                        no longer obeys the rule can drag parent character(s) 
                        into no longer obeying the parent rule (i.e. when 
                        "lset depend mutual" is in effect, as is by default): 
                        the son can effectively take any state, not just those 
                        that obey the rule. Thus, for multistate characters, 
                        the possible states are all, not just those compatible 
                        with the rules; this makes a difference in the case of 
                        multistate characters. Cases where transitions into a 
                        state other than the one in question would cause a 
                        rule to become enforced (for parents) or to no longer 
                        be enforced (for sons), are indicated in the tables 
                        shown by "vlinks&;" with an "X" (i.e. cases where 
                        some transitions would eXit rules). If you want to 
                        restrict the states to only those that obey rules 
                        (e.g. if you consider that a parent can drag son 
                        characters when changing, but believe changes within 
                        the rules are more likely), then you can use the  
                        "xlimit" option; this option restricts the state 
                        sets of possible ending states of every transition. 
                        Note that this makes a difference only for multistate 
                        characters, and only under "lset covary"; parent  
                        characters are always affected, but son characters 
                        are affected only with "lset depend mutual" (these 
                        are the default settings of "lset" anyway) 
 
MAJORITY
    Calculate majority rule tree (MRT) 
    =N       use N as cutoff 
    N/L      display MRT for tree(s) N, excluding taxon (taxa) L 
    [J]N/L   calculate frequencies for each group of tree J, 
              on tree(s) N, pruning taxon (taxa) L 
    (J)N/L   same, but display results as table 
    *N/L     same, but keep MRT as last tree in memory 
    &N/L     show and save MRT as last tree in memory 
 
MATCHTAX
       This command allows establishing possible taxon correspondences for 
    two trees with different taxon sets (e.g. larvae vs. adults, e.g. males vs. 
    females), and identifies taxa that (based on topological correspondence) 
    could be made equivalent (e.g. matching unmatched larvae-adult, or males- 
    females).  To understand how this works, you can try as example: 
      
                        A  B C D   X B C Y 
                         \/ / /    \/ / / 
                          \/ /      \/ / 
                           \/        \/ 
      
                    which produces:                                  
      
                         A=X  B C D=Y 
                            \/ / / 
                             \/ / 
                              \/ 
      
    Please note!  This command is experimental and not very efficient; it 
    may be replaced in the future by better algorithms. It is intended only 
    as a proof-of-concept implementation. 
        X Y       for taxa present in only one of the trees, identify 
                  possible correspondences between taxa in each tree, 
                  by enumerating all possible combinations of correspon- 
                  dences and counting the number of consensus nodes for 
                  each.  Practical only for low numbers of unmatched taxa 
                  By default, it uses the semi-stric consensus; preceding  
                  the tree numbers with "-" it uses the strict (preceding  
                  with "+" re-establishes the default).  This option  
                  establishes up to 100 possible sets of correspondences. 
       !X Y       instead of number of consensus nodes, use the sum of steps  
                  of the MRPs as criterion (making the trees more similar), 
                  matching taxa heuristically (with cycles of perturbation 
                  and improvement using taxon switches guided by changes 
                  in the mapping of each MRP on the other tree).  Faster, 
                  but not guaranteed to produce optimal results.  This must 
                  be the first argument (preceding "Other options"). 
    Other options: 
       Preceding tree numbers: 
           &      show list (instead of tree-diagrams) 
           *      save the trees with taxa replaced (e.g. for subsequent  
                  calculation of a supertree, combining the trees with the  
                  unmatched species found in only one of the trees). The 
                  taxa in second tree are replaced by their equivalent in  
                  first tree; unmatched taxa retain their own label. 
           :P     use a penalty P for not matching.  This differs in the  
                  enumerative and heuristic options.  For the enumerative, 
                  P can be interpreted as the "distance" in number of  
                  nodes to establish a matching (taxa more than P nodes 
                  away in the trees are left unmatched). For the heuristic, 
                  P is added to the MRP score of the two trees with a pair 
                  of unmatched taxa, so that accepting the non-match depends 
                  on how much the MRP steps are improved by non-pairing. 
           +      consense with bremer (=semistrict) consensus[default]. 
           -      consense with strict consensus. 
      Following tree numbers: 
                  The two tree numbers can be followed by a list of user-set 
                  possible correspondences (default tries to match every  
                  taxon in only tree A with every taxon in only tree B). The 
                  format to specify allowed and forbidden correspondences is: 
      
                         /taxon_a = taxon_x taxon_y  /taxon_b ! taxon_x  
      
                  which means that taxon_a of one of the trees can be the 
                  same as taxon_x or taxon_y of the other, but no other 
                  correspondence is allowed, and that taxon_b in one of the  
                  trees can be matched to any of the taxa only in the other  
                  tree except taxon_x.  Note that "/a=b" is not equivalent 
                  to "/b=a" if there are several taxa of uncertain matching 
                  (the first limits possible matchings of a, the second 
                  limits possible matchings of b).  
    See also under "help+matchtax" for use in scripts. 
 
MAP
    N/L    map character(s) L on tree(s) N 
    -      show optimization for character(s) L on tree(s) N, as a text list 
    :      show down-pass state sets instead of final 
    [      state super-sets for character(s) L on consensus for tree(s) N 
 
MINMAX
    ;    show minimum-maximum possible steps for each (active) character 
    -    same, considering only active taxa 
    *    combine minimum/maximum in a single table 
    +    show minimum-maximum for continuous character(s) 
    <    show only minimum 
    >    show only maximum 
 
MIXTREES
    N/L    combine trees N (with different sets of taxa), excluding taxon 
           (taxa) L.  Combines only uncontradicted groups. Using =J it does  
           J different input orders.  Using =[J k] it recalculates consensus 
           every k randomizations, until stability is reached J times. 
    *N/L   save the tree as last memory tree ( default = show) 
 
MKMAP
    T C    Map character(s) using Mk model, for tree T, character(s) C; 
    Options: 
      =N        show state sets only, for states with likelihood contribution  
                N or more relative to next best state (0 < N <= 1 ). If N = 0  
                (=default), then it shows the relative contribution of each 
                character. 
      *         display branch lengths on a tree-diagram (in this case, the 
                character(s) to map can be ommitted) 
      \         use uniform branch lengths, optimized on a per character basis 
                (=implik model, Goloboff & Arias 2019). 
      T C/var   instead of optimizing branch lengths of tree T based on all  
                active  characters, get branch lengths from user variable "var". 
                If a branch length negative, optimize it (as in Mk model ). 
    This can be used to map morphotypes as well (if defined with "xlinks"), 
    by using "|" or "&" after tree-number: 
           mkmap T | 0 1 2        map all morphotypes resulting from combining  
                                  character-states of characters 0, 1 and 2 
           mkmap T & 0 s0 & 1 s1  map morphotypes having character 0 with state s0, 
                                  and character 1 with state s1 as state "A", 
                                  and other morphotypes as "B" 
    Note! This assumes a common model for all the characters; included only  
    to facilitate experimenting with Mk model. 
 
MONO
    N    check whether tree(s) N satisfy constraints 
    -N   check whether tree(s) N violate constraints 
    *    same, but reporting group by group 
 
MRP
    Create matrix representing trees in memory. With "-", it 
    skips the "ROOT" all-0 taxon (this makes "unrooted" 
    source trees possible; beware 3-taxon trees!). 
 
MULT
    do N random addition sequences, followed by rearrangements. 
    Options are: 
      wagner       no branch-swapping 
      spr          use SPR branch swapping 
      tbr          use TBR branch swapping 
      [no]keepall  keep the trees from all replications 
      replic N     do N replications  
      hold N       save up to N trees per replication (only if swapping) 
      [no]ratchet  do ratchet as well (settings with "ratchet" command) 
      [no]drift    do drift as well (settings with "drift" command) 
      [no]wclus N  after adding N taxa to the wagner tree, start using 
                   node clusters (of size defined with "bbreak:clus SIZE"). 
                   Useful only for very large data sets (several K-taxa). 
      outfreq N    frequency for which reports are produced during branch 
                   swapping (default is every N=10 clips, but for large data 
                   sets this implies reports take too long to be produced). 
      ras          use randomized addition sequences for Wagner trees  
                   [default, works best for most data sets] 
      cas N        use closest-addition sequence for Wagner trees (ties in 
                   the addition sequence broken randomly), looking ahead up 
                   N taxa (no N = all taxa). Tends to work best on data sets 
                   with a lot of incongruence. 
      fas N        as previous one, but using furthest addition sequence 
      ias N        as previous one, but select first those taxa which make 
                   the largest number of characters informative (N.B. only  
                   additive/nonadditive characters considered for this; the 
                   other character types have no influence on the sequence). 
                   Tends to work best on data sets with many missing entries 
                   and non-overlapping blocks of data. 
      sas N        as previous one, but select first those taxa with the  
                   largest difference in score for best/worst locations (N.B. 
                   all character types are considered). Works best for the 
                   same data sets as the previous one ("ias"), but it is 
                   more thorough and slower 
    Usage: "mult:options;" changes settings only; "mult=options;" runs 
    as well.  Entering "mult:;" current settings are reported.  Setting 
    the type of addition sequence also determines the sequence to be used 
    in other commands (e.g. "xmult", "pfijo").  The insertion sequence 
    is always random for "cas", "sas", and "fas"; it can be changed (see 
    under "rseed") to be random or non-random for "ras" and "ias" 
 
MXRAM
    N   Use N Mbytes of RAM.  The default is 16 MB. 
        Must be changed before reading the data, or the  
        data will be lost. 
    ;   report amount of free RAM 
    +   when allocating memory for searches, make sure that 
        at least an additional 5% of free memory is available; 
        report an error before starting the search otherwise 
        (this decreases the likelihood that the program will  
        run out of memory _after_ having started the search). 
    -   don't require a free 5% (use it only to squeeze the  
        last few bits of memory out of your system; make sure 
        you don't use it together with the default, "mxram[;" 
    [   when reading a dataset, increase available RAM if needed 
    ]   don't 
    *P  when calculating expected amount of RAM for reading a 
        dataset, multiply by proportion P (1.00=use expected RAM) 
 
MXPROC
    N   allow up to N nested input files (default=10) 
 
NAKED
    =   show tree diagrams without numbers (default) 
    -   with 
    ]   draw trees in narrow format 
    [   in default (=wide) format 
 
NELSEN
    Calculate strict consensus tree 
    N/L    display consensus for tree(s) N, excluding taxon (taxa) L 
    *N/L   same, but keep consensus as last tree in memory 
    N/L/P  display consensus for tree(s) N, excluding taxon (taxa) L, 
           and indicate placement of taxon (taxa) P (P may refer to 
           node numbers in the consensus) 
    <      always use low-memory algorithm (sometimes, faster) 
    >      use low memory algorithm only when memory is low 
    Note that settings established with ">" and "<" also 
    affect the "tcomp" command. 
 
NSTATES
    N      set maximum number of states in matrices to be subsquently read to N 
           Note that 8 or fewer states is stored as char, 9 to 16 as 4-byte int 
           and 17 to 32 as 8 byte ints.  Maximum number allowed for discrete data 
           is 32 states.  Letters A-V are states 10-31. 
           Using the strings "DNA," "PROT," or "NUM," determines 
           whether data are read as dna, amino-acids, or alpha-numeric. The 
           string NUM must be followed by the number of states; DNA or PROT 
           automatically set number of states to 8 or 32. Under DNA or PROT, 
           IUPAC one-letter codes represent nucleotides or amino-acids. 
           For DNA, AGCT are states 0123 respectively; for proteins, 
           A,C,D,E,F,G,H,I,K,L,M,N,P,Q,R,S,T,V,W,Y,U are states 0-20. 
           Strings "GAPS" and "NOGAPS" determine (respectively) whether 
           gaps are read as fifth state or missing (=default). 
    *      resets all characters as alphanumeric; subsequent 
           merging of data sets with different data sets becomes easier if all 
           data sets are saved as alpha-numeric 
    &      like previous one, but sets all characters to type DNA. 
    min    deletes uninformative states for non-additive characters, so that 
           each character has as few distinct states as possible 
    stand  standardize continuous characters, so that minimum number of steps 
           equals a specified value.  Format is: 
               stand F L  rescale character(s) in list L (default=all continuous) 
                          to have a minimum of F (default F=unity).  If F  
                          preceded by "*" then it rescales so that the minimum  
                          for the set of active taxa equals F (all taxa are 
                          rescaled, however; minimum for the full taxon set 
                          may then exceed F). 
           N.B. as the internal values for continuous characters are stored 
           in 16 bits, repeatedly changing scales leads to a loss of precision. 
    lstand convert into log and then standardize; this shifts scale so that cost 
           of changes is proportional to the magnitude of the states. Format is 
           similar to "stand", except that "-" (instead of "F") turns scale 
           back to original (i.e. de-converts the logs), and "*" is not 
           allowed. Logs are calculated from the original scale; values of 0 
           cannot be converted (they can be shifted with "nstates shift") 
    shift  followed by a number N (can be positive or negative), shifts the 
           original scale of subsequently specified continuous characters 
           (note: the characters to shift cannot be in log form) 
    fix    for the continuous characters listed, make the original scale equal 
           to currently stored values. 
    xmin   for non-additive characters with polymorphisms, calculate minimum 
           possible numbers of steps (and thus, informativeness and homoplasy) 
           using exact algorithms (=default; these may be time consuming for many 
           states and many polymorphisms).  With "noxmin", a heuristic is used 
           to determine minima (it may underestimate minimum). 
    /      followed by the strings "DNA," "PROT," or "NUM,"  determines 
           how to read states in commands that refer to states (i.e. cost, or 
           change commands).  This does not alter the matrix itself. 
    [      if the matrix contains continuous characters, and these were rescaled, 
           display values in the original scale.  Keep in mind that there may  
           be some imprecision in the conversion back.  This affects only the  
           commands that calculate branch lengths, map characters on trees, and 
           give lists of synapomorphies.  Tree lengths themselves continue being 
           the same, as the characters continue being stored internally as 0-65 
           with 3 decimals.  This does not affect, either, the values returned 
           by scripting expressions (including iterrecs); those have to be  
           converted explicitly by user with the "contscale" expressions.  The 
           rescaled values will be displayed using the number of decimals set  
           with the table precision command ("table/"). 
    ]      display continuous characters in the scale stored internally. 
 
OUTGROUP
      N     make taxon N the outgroup (default = 0 ) 
      [XXX  if taxonomy has been defined, make group "XXX" the  
            "taxonomic outgroup".  This is a possibly multi-taxon 
            outgroup, which may be used to root the trees after  
            searches, or with the "reroot[" option.  In case the  
            taxonomic outgroup does not exist in the tree, the closest 
            group is used (if nothing resembling the ingroup/outgroup 
            partition exists, then a note is displayed, and the tree is 
            left rooted on the regular outgroup). If the name "XXX" is 
            ommitted, then the taxonomic outgroup is guessed form the  
            taxonomy.  To have TNT reroot the trees after a search, use 
            "!" before the category name (default is rerooting trees 
            only when a "reroot[;" command is issued). 
            Note that if you have some Sankoff characters with asymmetrical 
            transformation costs, or have the "piwe+" option in effect, 
            then it is possible that using the taxonomic outgroup may 
            alter tree scores. 
 
PROCEDURE
    Redirect input 
      XXX;   take commands from file XXX. If file begins with "#NEXUS", 
             then it is interpreted as such. Only simple Nexus datasets 
             can be read (see under "xread") 
      /;     close input file (include at end of file) 
      &XXX   read Fasta file XXX.  It must be aligned.  If not, all 
             sequences can be "equalized" to N characters, by adding 
             gaps at the end, if & is followed by =N (alternatively, 
             =N can be placed at the beggining of the file. 
      [XXX   read file XXX as Newick trees (e.g. RAxML trees) 
    Note that input may also be redirected automatically (almost  
    within any context) using "@@filename tagname;" (reading is 
    from point marked with "label tagname" on, with end of 
    automatic redirection indicated with @@; if a dash, -, is used 
    instead of tagname, the file is done from the begginning) 
 
PAUSE
       =   enable pauses on output 
       -   don't (default) 
 
PCRPRUNE
    Improve consensus by Iterative PCR (Pol & Escapa, 2009). 
         N/L\U      improve consensus of tree(s) N, excluding taxa 
                    in list L, but never removing taxa in U. 
    List of trees may be preceded by:  
          =C    maximum number of taxa to cut at a time (default=all) 
          :K    assign a cost of K (0-100) to taxon remotion (higher 
                K's require more nodes gained for a taxon removal to 
                be accepted as "improvement"; default=0.5) 
          >N    only show prunings which improve N nodes or more 
                (for strict consensus only, not for majority) 
          [N]   improve only node N of consensus (for strict  
                consensus only, not for majority) 
          &     for pruning strict consensus only, when finding that 
                a triplet is present in all trees, try to combine  
                with previously checked triplets to infer resolution 
                of triplets not yet checked.  Faster for larger numbers  
                of trees, differing in fewer taxa 
    and if followed by ">N", all the prunes are added to taxon-group 
    number N (note that this option requires an explicit tree list, for 
    otherwise it would be interpreted as the option to only show prunings 
    which improve N nodes; see above). 
    The consensus types can be indicated in parentheses, also before 
    tree-list: 
      (majority F)  heuristically try to improve majority rule tree,  
                    considering that triplets occurring in frequency F  
                    or higher are "compatible" (50<=F<=100, default=50) 
       (nelsen)     improve strict consensus tree (=default) 
 
PFIJO
    Run pinon fijo (a search algorithm useful for very large data sets). 
    The algorithm creates reduced data sets from sectors in the tree 
    (but instead of using the htu's, as in sectsch, it uses, with a certain 
    probability, the down-pass states of the descendants of an internal node). 
    The states for the basal node --which produce exact score evaluations for 
    the reduced data set-- have the highest probability of being chosen, and 
    descendant nodes have subsequently smaller probabilities.  The outgroup 
    node for the reduced data set is chosen from one of the terminals outside 
    the group (randomly chosen). The reduced data set is analyzed by means of  
    three RAS+TBR, then fusing these three trees with the original one. 
    Typically, this produces a tree different from the original one, which 
    is suboptimal for the complete data set (i.e. some HTU's are not 
    represented by their down-pass states, the root states are different), 
    and this perturbated tree is then used for TBR and three cycles of  
    mild tree-drifting.  Optionally, the trees produced can be fused every 
    certain number of rounds.  This is a sort of ratchet, where the  
    perturbation is provided, not by character reweighting, but instead 
    by choosing subsets of taxa. 
      The sectors chosen are large, exclusive sectors (size chosen so that 
    it is below or above two sectors for the sector size to be 500; this 
    size can be changed, with "chunksize" --see syntax below); the actual 
    selections depend on the current random seed. 
      The probabbility of choosing HTU states is determined by making an  
    upward list of the L nodes descended from the HTU, generating a random 
    number R (0-99), and based on the user-set constant K, converting into an 
    integer i the expression ( L * (1000 - (10*K) ) / ( (100 - (10*K)) + R ). 
    Then, the down-pass states (or observed states, if a terminal) of the ith 
    element in the list of descendants is chosen to represent the HTU states. 
    Syntax is:  
                 pfijo N = [options] ;  
    If the '=' is replaced by ':', then only settings are changed. 
    N is the tree from which pfijo is to be started (if no N is specified, 
    each of the trees in memory is sequentially subjected to pinon fijo). 
    Options are:  
       phtu K   Change probability of HTU substitution.  K is a real number  
            0<0<100, with larger values making more probable that the actual 
            HTU states are chosen, i.e. lower values perturbate more strongly; 
            (default K=95) 
       numsels N   number of cycles to do (default N=30) 
       [no]goback  if new tree, after global TBR and drift, is worse than 
            starting tree, go back to starting tree (default = don't go back) 
       [no]keepall   save trees as cycles proceed, or save only best trees 
             (default: save) 
       autofuse N R  every N cycles, fuse (R rounds) the trees produced. 
       drift N F R  after perturbation, do N cycles of drifting, with a fit 
             difference F, and a relative fit difference R (default is  
             drift 3 3 0.1) 
       chunksize N  select sectors of approximate size N 
       slack N  use an extra N percent memory to create reduced data sets 
 
PIWE
      -    set implied weighting off (=default ) 
      =N;  set it on, with weighting constant N (0 < N <= 1000) 
      :N   set weighting constant only 
      [    followed by a list of weights, sets relative weights for 
           implied weighting (starting from 0 extra steps). Followed 
           by a semicolon, displays current relative implied weights 
      |N   report the absolute cost of the Nth steps of homoplasy under 
           implied weighting (i.e. without rescaling first step to 1). 
      ];   deactivates user-defined implied weights 
      +N   use auto-weighted optimization instead of implied weights, with 
           weighting constant N.  This does implied weighting at the level 
           of character-state transformations; it can be very time-consuming  
           for data sets with many taxa and/or states.  General options  
           and parameters for auto-weighting are set with the "slfwt" 
           command. 
      <R   for the matrix at hand, set concavitiy to a value such that the 
           maximum ratio of implied weights can be 1:R (this depends on the 
           maximum possible steps of the matrix; see Goloboff et al. 2008). 
           If R is followed by another number N, then the concavity is chosen 
           to give the 1:R weight ratio to N steps of homoplasy. 
       &   when using multiple concavities, show k values for individual 
           characters (if not using a user-defined weighting function), 
           or the "shift" (for a character with shift S, the cost of adding 
           one step to N steps of homoplasy is the same as the cost of adding 
           a step to a character with S.N steps with the user-defined weighting 
           function.  If a list L of characters is given after after "&, then 
           the relative cost of adding a step to a different numbers of extra 
           steps (as in "piwe[;"), for the characters in L. 
 
PRUNCOM
    Find pruned combinable component consensus.  Syntax as in  
    "prunnelsen" --options + and ! not allowed. 
 
PRUNMAJOR
    Use a quick-and-dirty heuristic to identify taxa to prune 
    in order to improve majority rule or frequency difference 
    trees.  It checks by reference to specific groups (i.e. groups 
    present in a reference tree).  General syntax is (defaults in 
    square brackets): 
                prunmaj T N1 N2 N3 .. Nn / S / L \ U ;  
    where T is number of reference tree [mandatory], N1-Nn are node numbers 
    [all], S is the set of trees to consider [all], L is the list of taxa 
    to exclude [none], and U is the list of taxa that cannot be excluded 
    from the tree (=Untouchable). 
    Additional arguments that can precede number of reference tree: 
       &P      group proportion [0.333].  Set only, don't run. 
       [X Y    cost of removal inside (X) and outside (Y) [1,1]. Set only, 
               don't run. 
       +       show pruns for each node of tree T [don't]. 
       =N      show the best N values [1]. 
       *       try to improve frequency differences, rather than 
               just frequencies. 
    It is possible to add/remove taxa from taxon-groups, as final 
    arguments:  
        >G      add taxa with best N values to group G. 
        <G      ditto, removing. 
    The values are presented with an arbitrary rescaling between 0 and 
    1, with taxa having higher scores expected (recall this is a heuristic!)  
    to improve results the most. 
 
PRUNNELSEN
    =P N/L Show pruned trees with up to P taxa pruned (default=1) 
           for consensus of tree(s) N, excluding taxon (taxa) L. 
           Checks whether additional groups appear.  If you wish to 
           force inclusion of some taxa (terminals only), list them 
           at the end as "\L". 
    >N     show only prunings that improve more than N nodes 
    [J]    same, but only for node J of consensus 
    &      show list of prunings that improve consensus 
    *      store prunings that improve consensus (pruned 
           taxa are placed at the base of the tree)
 
    Using ">G" (or "<G") after the taxon list, then the taxa 
    pruned are added to (or removed from) taxon group G.
 
    The following two options calculate agreement subtrees:
 
    +      calculate agreement subtree exactly (cannot be used  
           with =, [N], or >, but can be used together with *  
           or &).  Agreement subtrees maximize number of shared 
           taxa, not number of shared groups. 
    !      approximate calculation of agreement subtree (for 
           binary input trees only). If used alone quickest, 
           if used with + intermediate. Saves or lists a single 
           tree. 
 
PRUNTAX
    N/L   prunes taxon (taxa) L from tree(s) N.  If symbol 
          "!" is used as taxon list, it prunes all inactive 
          taxa.  If "*" is used instead of tree list, then it 
          prunes taxa from tag-tree; using "=xxx;" instead of 
          taxon list, then it prunes all terminal branches labeled 
          as "xxx". 
 
PRUPDN
    Try combinations of pruns, for taxa specified in a group, to improve 
    majority rule or frequency differences, and place the best set(s) in 
    an output taxon group.  It uses an optimality value to evaluate pruns, 
    consisting of E = ( Sum(v) + P ) / ( T - 2 ), where Sum(v) sum of  
    support values across all branches of pruned tree, P = penalty for 
    prunes, T = number of taxa with least possible prunings.  P is defined  
    as R * 100 * ( 1 - F^2), where R = number of taxa pruned, and F = factor 
    to penalize removal (larger values, stronger penalty; default is 0.5). 
    It can work "down" or "up" (hence the name of the command); down 
    starts with no prunings and tries combinations of prunes to improve  
    E (moving taxa pruned in one stage to the output taxon group), and up 
    starts will all taxa pruned, finding the best combination of taxa to 
    unprune at each stage.  At every stage, it tries combinations of up 
    to M taxa to prune or un-prune.  
      This command is useful to take taxon groups resulting from more 
    heuristic commands (e.g. "chkmoves", "prunmajor", "pcrprune", or  
    "prunnelsen") and refine the prunes with a more exhaustive and 
    optimality-based evaluation. 
    Usage:  
           prupdn G1 G2 options L / N  
      
    will take taxa in group G1 (placing result in group G2), for trees in 
    list L, ignoring the position of taxa in list N, with options specified. 
    Options are: 
      [T]   use groups of tree T as reference (default=majority or GC of trees 
            in list L). 
       >    use a "down" pruning (=default) 
       <    use an "up" pruning 
       :F   use F as factor for penalty (0 <= F <= 100) (default = 0.5) 
       *    use frequency differences instead of raw frequencies 
       =M   at every stage, use a maximum of M taxa pruned (or un-pruned); 
            at every stage, the best set of prunes (or un-prunes) is removed 
            from the set of possible prunes (or un-prunes) (default = 3). 
       &N   use N for cutoff (e.g. N=100, improve strict consensus) 
       !N   perform at most N replications (default = 20) 
       |S   use a "separator" value of S.  With this, two taxa separated  
            by nodes with support value S or more, are never pruned in  
            combination (as it is less likely that their joint elimination  
            will improve much the tree); this speeds up calculations but 
            may miss some improvements (legal values are 0<=S<=100).  In  
            the "down", the default is to use separators of 75 (use 0  
            for no separator, i.e., all combinations actually evaluated); 
            in the "up" mode, the default is not to use separators, and 
            they are used only if explicitly indicated. 
 
PTNT
    manage runs in parallel (parallel versions only).  Keep in mind that 
    versions for 16383 taxa or less can't communicate with versions for more 
    than 16383 taxa (mixing 32-bit and 64-bit versions should be ok). 
    again    re-send instructions to slaves, without re-sending data. With 
             this, it is possible to save communication time. Syntax is: 
      
                  ptnt again jobname tasklist /trees N S /deltrees /swap N 
                             = ...new slave commands...; return;  
      
             if no tasklist is given, all the tasks of jobname are re-set; 
             if no "trees" selection is specified (and "swap" isn't 
             specified), then no trees are sent; if "deltrees" is 
             indicated, the trees in slave(s) are deleted. 
             If "swap N" is specified, then it swaps tree N (deleting any 
             preexisting trees in the task); if several trees are to be 
             swapped in parallel, it is best to use "again" instead of 
             "begin" for each one, since "again" doesn't require that 
             the data be re-sent to the task(s) ("begin" does!). 
             Using "..." as instructions, then the previous instructions 
             for the slave are repeated.  
    begin   begin a job.  Up to 32 jobs can be running at the same time; 
            every job can have up to 1000 tasks.  Syntax is: 
      
                  begin name numt hosts = tnt commands ; return  
      
             name is the name by which the job is identified, numt the  
             number of copies of the process to run, hosts is a list of 
             the hosts in which to run (can be the names used by PVM, or 
             the numbers; current host is identified as "myself" and 
             host of parent process (if it exists) is identified as  
             "parent" (this makes scripts more portable; also, in the 
             list of hosts, the machine where the master TNT runs is 
             always number 0, and the machine where a slave itself runs 
             is always number 1 within that slave); "master" identifies  
             the master node (i.e. where TNT was started). When no list 
             of hosts is given, if the executing process is the master, 
             all hosts but the current one are used, or, if the process is 
             a slave, all hosts but the one where parent process runs. If 
             neither numtasks nor hostlist are given, one task per available 
             slave host is used (except for exclusive sectors, which spawns 
             as many tasks as selections).  If you wish to specify the 
             number of tasks to be spawned in a host (or hosts in a group), 
             include the number of tasks in parenthesis right after the  
             name of the host (or group of hosts, i.e. before the closing 
             braces; note this specifies the number of tasks to start in 
             every host of the group).  If several numbers of tasks are 
             specified, the last one takes effect (no number = 1). Current 
             (or reduced) data are automatically passed to each of the  
             daughter processes (each of which has a different random seed). 
             The '=' symbol can be preceded by one or several slashes ('/') 
             indicating: 
                ram N      N: RAM to be used in each slave, in MBytes  
                           By default, TNT instructs each slave to allocate 
                           an amount of RAM that should be sufficient for  
                           most operations on the current data set. 
                ram xN     slaves use N times default RAM 
                trees N S  send N trees randomly picked from the set S (a 
                           list of trees) to each slave; using '.' instead 
                           of N, divides S in equal parts 
                trees *    distribute tree-groups, sending task i all the 
                           trees in group i 
                sector N S random selections of size N from tree set S 
                           (as many selections as tasks; every task gets 
                           a sector from a tree randomly picked out of S) 
                sector*N T create N exclusive sectors from tree T 
                           (size set to taxa/N, tasks set to N). 
                           If "*" followed by "-", allow looser 
                           (partly randomized) selections.  If a list 
                           of sectors follows N (within square brackets), 
                           then only those sectors are effectively launched. 
                           When only some sectors were launched, and results 
                           are recovered/spied, two copies of the best tree 
                           in each slave (with the rest of tree polytomized) 
                           are placed in tree-group "TreeSector_i_xxx" 
                           (where i, task number, and xxx, job name).  This 
                           can be used to re-insert the resolution for the 
                           sector into the main tree, or combining the 
                           results for successive sector analyses, using 
                           the "freqdifs" command (i.e. two copies of the 
                           reduced tree and a single copy of the original 
                           one, produce the replacement; make sure you 
                           turn temporary tree-collapsing off for this). 
                           Note: under "sec:chkroot" the number of sectors 
                           created by this options is determined at run-time; 
                           use the "treeparts" expression to find in 
                           advance how many. 
                sector d N X  select nodes around node N (of tree specified 
                           with "/trees"), up to X branches away from N. 
                sector !N >X <Y T  select node N of tree T and immediate 
                           descendants; if a descendant has a polytomy 
                           greater than Y, or smaller than X, it is used 
                           as such; otherwise, the immediate descendants  
                           of the node are used (this avoids creating HTU's 
                           from poorly, or unresolved clades). To create 
                           the HTU-s, the tree is dichotomized if needed. 
                swap N     perform TBR-swapping in parallel, on tree N. 
                           When done, task 0 has the final tree (which, 
                           if no errors occur, is TBR-optimal).  If some 
                           error occurs (e.g. machine where process 0, 
                           which is the leader, dies), then the tree is 
                           lost. This works best when trees are closest 
                           to optimal (i.e. communication time is required 
                           only when a better tree is found by some task). 
                           When using "swap", instructions to slave tasks 
                           are ignored (tasks only swap tree, and return). 
                           Options: -N doesn't sort swaps; +N uses process  
                           as controller (controller doesn't swap) 
                dskdata    read data from disk, not from PVM (data must 
                           have been set before, with "ptnt setdata"). 
             If several "trees" selections are indicated, selection i is 
             guaranteed to have at least Ni trees taken out of each set Si; 
             up to 8 tree selections per job can be indicated.  If the sets 
             for each selection i are disjoint, total number of trees sent 
             to each slave will be the summation of the individual Ni's; 
             otherwise, it may be less. 
                 A slave may begin other parallel jobs; if it does so, 
             giving "..." as list of TNT commands simply copies commands 
             for the current job (use this cautiosly: there must be a way to 
             eventually stop slaves from spawning further jobs, e.g. with 
             the "plevel" expression --the number of parents).  User 
             variables are interpreted on local host when using single 
             quotes ('0') and on slave host when using double quotes ("0"). 
             String "return" can be followed by keywords "[no]trees", 
             "text", "value N" or "tgroups" (if exclusive sector 
             selection, options "polytree" and "nopolytree" determine 
             whether polytomized tree is sent back; otherwise polytomized 
             tree is sent only if initial score bettered/matched). 
    catchout PVM only, capture output to stderr from slaves (disconnect  
             with "nocatchout"). Slaves write to stderr with "lquote>;". 
             The "catchout" option must be given prior to starting job(s). 
    cleansig remove any signals with info from slaves that may have 
             been left over by the last "wait".  It may be necessary 
             if "goto" or "again" are to be applied to a job that 
             had finished running, and the job is to be "waited" 
             again.  It is also advisable to run this (with "again") on 
             slaves interrupted (=stopped) while doing parallel TBR 
             and about to be reused for further parallel TBR. 
    close    kill all active jobs and disengage TNT from PVM.  With this,  
             PVM can be halted and TNT continues running normally. If PVM 
             is halted and TNT is in parallel mode, TNT is killed. 
    cmdname  define name of command to be displayed by parent process 
             (copies until a semicolon found; "-" undefines). 
    commtime set communication time (periodicity of signaling). 
    encode   set type of PVM encoding for communication with slaves.  
             Options are "raw" and "default" (for single/several  
             machine architectures).  Must be set in slave processes too. 
             The default is using the current status, but this may create 
             problems if a homogeneous cluster becomes heterogeneous 
             (or viceversa) in the middle of a run. 
    get [!]  get results from job(s).  Job(s) must have finished running 
             (or have been stopped (with "ptnt stop job;").  If jobs 
             have not finished, "get" waits for the last one to finish 
             (or untill timed-out). Alternatively, if using "!" as  
             first argument to "get", slaves are stopped right away 
             (with the default stopping signal, see below). If get is 
             being executed in the master, it can be stopped pressing <esc> 
             (which calls the error handler, clearing all input buffers), 
             or pressing '.' (period, which skips the get but continues 
             normally with the rest of operations.  If a single job is 
             being retrieved, maxtrees is reset automatically (if needed). 
             If you retrieve several jobs at the same time, maxtrees  
             is not reset automatically (excess trees are lost). 
    getbufs  get text-buffer from job(s).  
    goto N   similar to skipto, but if "tagset N;" already executed, 
             rewinds instructions. 
    gwait () monitor, and when condition fulfilled, stop jobs and get'em. 
             (note: gwait never resets maxtrees; excess trees are lost). 
    halt     a synonym of "stop" (to use, e.g. within loops) 
    hgroup   define group(s) of hosts (syntax as in "tgroup"). 
    hosts    list available hosts 
    hpause   pause all slave tasks working in given host(s). 
    hresume  resume all slave tasks working in given host(s). 
    kill     kill job(s); no results returned. 
    load     show host usage 
    mnemonic when possible, remember values read in last ptnt wait (then 
             subsequent accesses to number of trees, scores, etc., in 
             slaves, take no time; note however that the values may not 
             be current anymore).  If memory is reassigned (e.g. max. 
             trees is changed), then values are forgotten.  Mnemonic is 
             turned on/off with +/-.  
    pause    pause job(s); releases CPU time (but not RAM) on slaves  
             Can pause individual tasks (say, 0,3)for job jobname 
             using "ptnt pause jobname = 0 3;".  If master is running 
             in the background, all jobs can be paused by creating a 
             file "pause_tnt_ID" (where ID is the number of process 
             id of master) in the working directory (using "stop_tnt_ID" 
             instead, all jobs are stopped) 
    reset    reset job list (no active job can be running). Memory 
             requirements on TNT are eased if this is done often. 
    resume   resume job(s) that are paused (automatic with "get"). 
             Can resume individual tasks (say, 0,3)for job jobname 
             using "ptnt resume jobname = 0 3;". 
    setdata  write data file (.tnt_tmpfile) in specified hosts(s) 
             (can indicate other directory, in square brackets, after 
             list of hosts; in such a case, then before launching jobs 
             you have to tell TNT where the directory is, with  
             "ptnt setdata = dirname;").  After setting disk data, 
             subsequently started jobs can read the data from disk 
             instead of having PVM transfer the data (which is time 
             and memory consuming), using the "dskdata" option. 
    setram N instead of master assigning RAM to slaves (based on 
             current settings), assign a fixed amount of N (MBytes) 
    skipto N skip instructions, in job/slave(s) specified, to the point 
             marked with "tagset N;" (if already there, ignored). The 
             slave cannot find a tag within a loop, and must still 
             be executing instructions (skipto is ignored if slave 
             is already on "return" stage, i.e. the last tag). 
    spy      get trees from job(s), but let the jobs continue running. 
             If a single job is being specified, a list of tasks(s) 
             can be specified as well (after a forward slash). Note: 
             this only gets the trees from immediate slaves (not their 
             children or grandchildren).  Maxtrees reset automatically 
             (as in get), only when a single job is being spied. 
    status   report status of all active jobs. 
    stop [s] stop job(s); returns results so far. 
             Optionally, stopping signal can be determined inside 
             square brackets: wait, loops, search, or all. Wait stops 
             the monitoring for slaves (present and future), but not 
             calculations or searches themselves. Loops lets presently 
             executed loops to continue, but subsequent ones are stopped. 
             Search assumes the timeout for present and subsequent 
             searches to be always met; it doesn't stop other calculations 
             (such as consensus calculations).  All stops calculations, 
             searches, monitoring (wait), and loops.  The default 
             stopping signal (which is the one get ! uses) has a different 
             effect depending on what the slave is doing; if monitoring, 
             (with pt wait) the monitoring is interrupted and subsequent 
             instructions (like searches) are performed; if searching, 
             the search is interrupted and the slave returns right away. 
    tagset N define tag to be N (useful within slaves, to coordinate 
             tasks; see under help+attag, and above, under "skipto" and 
             and "goto").  This is also a plain command. Truncations of  
             tagset are recognized to set values, but skipto/goto only 
             recognize the entire string. 
    timeout  set timeout (in secs.) to wait for slaves to return results 
             with "get". Default is no timeout (=0), but this may cause 
             fault-intolerance (i.e. TNT may freeze if a slave host died). 
    wait ()  monitor specified jobs (until condition indicated inside paren- 
             theses is met).  Numbers of trees, replications, tasks left, 
             &cetera, are accessed periodically (then, evaluated faster if 
             TNT is monitoring; otherwise, unless "mnemonic" is on, 
             signals requesting values must be sent to slaves, and  
             parent must await for response). If no condition is specified 
             it waits for all tasks to finish. A timeout can be specified, 
             before the parentheses, inside square brackets; if timeout 
             is met, wait exits even if condition is not fulfilled 
             (but then waitsuccess=0). 
 
QCOLLAPSE
    =   quick pre-collapsing during searches under mulpars (default) 
    -   no quick pre-collapsing 
 
QNELSEN
    Estimate consensus. Options are: replications N, select N, strictperc N, 
    majorcut N.  Search commands given in square brackets. Taxon exclusion with 
    "/" followed by list of taxa to exclude (from consensus; not from searches) 
    For each search, trees are collapsed according to current criterion. Option 
    "allow" works as in the resample command. When majorcut=100, then 
    the strict consensus for all replications is calculated. 
 
QUOTE
    copy from input to output until a semicolon is found 
    (if literal quotes is off, start on a new line, otherwise 
    new lines on output reflect new lines on input) 
     :xxx   if output is silenced to any of the devices (i.e. 
            file, console, or text buffer), temporarily de-silence 
            it to quote "xxx" and subsequently re-silence it again  
 
QUIT
    quit the program 
 
RANDTREES
    N J K  create N random trees, by adding taxa at each pre-existing 
           branch with same probability, probability J of collapsing  
           the new node, with up to K-furcations (default J = 0 ) 
    /      randomize tree order 
    *      randomly resolve non-binary trees 
 
RATCHET
    Ratchet, from trees in memory.  Options are:  
       iter N           number of iterations 
       [no]equal        periodic rounds with original weights [not] 
       numsubs N        number of replacements (i.e. accepted tree 
                        rearrangements) to do in perturbation phase 
       upfactor N       probability of upweighting a character 
       downfact N       same, for downweighting 
       [no]autoconst N  number of auto-constrained cycles 
       [no]giveup N     percentage of full swap to complete during perturbation 
       findscore N      if score N or better found, stop 
       [no]fuse NxR     every N iterations, do R rounds of fusing to the N 
                        trees 
       [no]dumpfuse     if fusing fails to produce a better tree, [don't] 
                        dump all the suboptimal trees 
       [no]tradrat      [don't] run the original ratchet (i.e. noequal, 
                        during perturbation swap to completion and don't 
                        accept equally good rearrangements). 
    Options are set with "ratchet:[options];" or "ratchet=[options];" 
    (first case changes settings only, second case runs as well). With 
    "ratchet:;" current settings are displayed 
 
RCOMPL
      B    Identify sequences that seem reverse-complemented in block 
           list B (only DNA blocks are processed; blocks with non-DNA 
           characters are skipped).  The command calculates the edit cost 
           (Needleman-Wunsch) of the sequences as they are (A), and with 
           one of the sequences reverse-complemented (R).  If A < R, then 
           both sequences are considered to point in the same direction 
           [if (R-A)/A < 0.2, then TNT considers that no decision as to 
           direction can be made].  If A > R, then it is assumed that one 
           of the sequences is reverse-complemented [again, only when  
           (A-R)/R > 0.2].  Using ">G" after the list of blocks, all 
           sequences (=taxa) that seem reverse-complemented are added 
           to taxon-group G. 
 
RDIR
    xxx    set path for "run" files 
 
REBUILD
    Do a ratchet-like search, with perturbation provided by randomly pruning 
    taxa from current tree, re-inserting sequentially, and swapping with TBR. 
    This command is useful for very poorly structured data sets (e.g. random); 
    similar to the "*" option of the "hybrid" command, looped many times. 
    The number of nodes deleted can be a fixed proportion ("pclip") or an 
    absolute number ("clip"), of terminals or clades of a specified "size". 
    This is done repeatedly (as in the ratchet); optionally, it is possible to  
    use the (best) results of the cycles as input for tree-hybridization (with 
    settings from "tfuse" command).  One of the best trees produced by  
    hybridization is then used to continue the rebuilding. 
    Options (possibly preceded by "no"):  
       clip J-K  at every cycle, clip a number of nodes between J and K. If 
                 this not specified (or 0), then it uses "pclip". 
       pclip N   at every cycle, clip N% of the terminals or nodes. 
       size N    maximum size of clade to clip (default=1). If N > 2, then 
                 (by default, see "ancfirst" option), clades are re-inserted 
                 back before their descendants.  If this set to 0, then it 
                 uses "psize". 
       psize N   maximum size, as proportion (percentage) of number of taxa. 
       cycles N  do N cycles of rebuilding (default = 4000). 
       reset N+S every N cycles that fail to produce a tree as good as best 
                 tree found so far (plus S, if specified), reset tree to 
                 best tree found so far and continue rebuilding from that one. 
                 Default = "noreset". 
       hybrid N  hybridize, N times, the best S trees produced by rebuilding 
                 (S=sample size, determined with "sample").  Each round of 
                 hybridization will use the results from as many cycles as 
                 specified with "cycles" (defaults N = 6, S = 50). 
       sample N  pass to the hybridizer the best N trees produced by rebuilding 
       ancfirst  If clipping clades of more than 2 terminals, reinsert ancestors 
                 before descendants.  Default = yes. 
       keepall   keep all trees produced by rebuilding, instead of best ones. 
       dump      after hybridization, if too many trees match best score, retain 
                 a small sample (10 percent of sample size), so that trees from new  
                 cycles of rebuilding can be saved for subsequent hybridization. 
                 With "no", hybridization becomes easily stalled by using a 
                 fixed set of near-optimal trees.  Default = yes.  
    Options are set with "rebuild:[options];" or "rebuild=[options];" 
    (first case changes settings only, second case runs as well). With 
    "rebuild:;" current settings are displayed. 
 
RECONS
    N/L;    most parsimonious reconstructions for character(s) L, tree(s) N 
      
    For mapping reconstructions of complexes of linked characters only, 
    the following options can be applied before list of trees:
 
      *      show a single reconstruction, randomly chosen from among possible 
             reconstructions (N.B. reconstructions are not equiprobable!). 
      [      the characters in the complex are shown at one line each, and by 
             default, inaplicable characters are skipped. With the "" option, 
             all characters are shown explicitly, even if inapplicables at that 
             node. 
      |      for each reconstruction, show the mapping of each member of the 
             complex on a separate tree-diagram (N.B. this is the only option that 
             the homoplasy of each individual character in every reconstruction). 
      (C:S)  If character/state names are too long, limit the names on the tree 
             diagram to C or S letters (C, for character names; S, for state) 
             names. Defaults C:S are 10:10. 
 
REPORT
      =         report status of time-consuming operations 
      -         don't (default) 
      +S/R/T;   during searches, record status every S seconds, R replications, 
                or T trees swapped (no record = 0 ) 
      [         with the +S option, also record progress bar when running 
                in background, every S seconds 
      ]         don't (default) 
 
REROOT
      N   re-root tree(s) N, using current outgroup 
      !   if outgroup part of a basal polytomy, resolve so that 
          outgroup is first split 
      [N  re-root tree(s) N, using taxonomic outgroup (see "outgroup") 
      *   also re-root tag-tree. The tags for groups which become paraphyletic 
          are assigned to the (now monophyletic) complement group (i.e. tags 
          remain in the same taxon partitions). 
      =P  re-root tree(s) (and tree-tag, if using '*') on point P 
          (if rerooting several trees, and P is an internal node,  
          this may imply different rootings for different trees). 
 
RESAMPLE
    Resample matrix, and calculate group supports. 
    Usage: "resample options [ search commands ];"  Options are: 
       allow           during each replication, allow execution of 
                       (almost) all commands, including dangerous ones. 
                       This option should be used sparingly and only when 
                       you really know what you're doing! 
       boot            use normal bootstrapping instead of the default 
                       resampling ("sym"). 
       cut N           cutoff frequency or support 
       errcount N      valid only under sibyl.  This counts the  
                       proportion of groups (out of the total 
                       supported groups) in the reduced data set 
                       that are not supported in the complete data 
                       set (wrong groups) and the proportion of groups 
                       (out of the total) in reference tree N (presu- 
                       mably, consensus of optimal trees for the 
                       complete data set) that are not supported by 
                       the reduced data set (mist groups). 
       frequency       summarize results with absolute frequencies 
                       instead of the default ("gc"). 
       from N          calculate support for groups in tree N 
       gc              summarize results with frequency differences 
       jak             use normal jacknifing (i.e. independent deletion) 
       poisson         use Poisson-modified bootstrapping 
       probability N   change probability for "jak" or "sym" 
       replications N  number of replications 
       savetrees       save consensus for each replication 
       sibyl           perform a backwards-jacknife; if used, this 
                       must precede all other arguments. See below 
                       for details. 
       slope           summarize results with frequency slopes 
       softboot N      make resampling in bootstrapping milder, by 
                       creating datasets with more characters (as in 
                       Kopuchian & Ramirez 2010). This has an effect 
                       only for "boot" or "poisson"; none for "sym" 
                       or "jak". 
       sym             use symmetric resampling, with p(up)=p(del) 
       zerowt          if doing symmetric resampling, eliminated (give 
                       weight 0) to downweighted characters (=default); 
                       otherwise, divide their weight by 2 (uncontra- 
                       dicted groups appear in all replicates) 
    Taxa can be excluded from consensus calculations, using "/" followed  
    by the list of taxa to exclude.  All options are persistent, except 
    taxon exclusion and "from" 
      
       The backwards jacknife is not a measure of support, but provides 
    instead a sort of stability test. It deletes characters (under 
    independent character removal, with p(del)=0.33); for each case, 
    runs the data (as indicated within square brackets) and count the 
    number of groups supported by the reduced data set that are present 
    in all previously existing trees ("supported") or present in some 
    but not all existing trees ("compatible").  Divide that number by 
    the total number of groups supported in the reduced data set, or by 
    the total number of groups that _could_ be supported in the reduced 
    data set (i.e. nr. of taxa-2 , "normalized"). The existing trees must 
    be provided by the user, and should correspond to a set of optimal 
    trees under current settings. Other than search commands, only the 
    number of replications can be changed, and taxa can be disregarded. 
 
RESOLS
    N/L;   show resolutions of polytomies in consensus of tree(s) N, 
           excluding taxon (taxa) L 
    [J]    same, only for node J of consensus 
    &      list resolutions 
    If a single node is specified, then adding ">G" (or "<G") after 
    list L, will add to (or remove from) groups starting at G the trees 
    for each of the resolutions. In this case, the number of resolutions 
    (=number of groups modified) is saved to scripting variable "listsize". 
 
RFREQS
    [T] N/L  show frequency of approximate recovery of groups 
             from reference tree T, in tree(s) N, excluding taxon 
             (taxa) L. For each group of T and each tree, it calculates 
             the "similarity" S to most similar group of tree, with 
             S defined as B/(B+(AxWa)+(RxWr)), where B=number of taxa 
             in both groups, or in neither (whichever is smallest), 
             A=number of taxa added to group, R=number of taxa 
             removed from group (Wa and Wr are weight factors to make 
             removal/addition more costly, set with "prunmaj") 
             If group adds/removes more than a certain proportion of  
             taxa (default is 0.333) then S=0. 
 
RIDDUP
    ;    deactivate duplicate taxa (according to current 
         character activities) and prune trees 
    *;   same, but leave two identical taxa active and in 
         trees (takes into account zero-length branches) 
    -    reactivate and reinsert duplicate inactive taxa 
    /    reinsert duplicates into tree-tags 
 
RSEED
      N    set random seed as N ( 0 = time ; default = 1 )  
      +N   increase random seed by N 
      *;   set a new random seed, at random 
      [;   in wagner trees, randomize insertion sequence 
      ];   in wagner trees, try insertions for new taxa from 
           top to bottom or from bottom up (=default) 
      >    in wagner trees, also randomize outgroup.  This  
           cannot be done when there are constraints or  
           asymmetric Sankoff characters (randomization is 
           skipped). Note that some "xmult" options use 
           internal constraints (and then skip randomization) 
      <    in wagner trees, outgroup is always the first taxon 
           placed in the tree (=default) 
      :N;  in multiple randomizations, instead of making sure 
           that each new seed is different from the ones used 
           before, increase the seed by N.  This may save time 
           in very extensive randomizations (where checking 
           previous seeds takes time).  When N=0, checks previous 
           seeds (this the default). 
      !    use quick approximation for randomization (faster) 
      -    use careful randomizations (slower, more random; default) 
 
RUN
    xxx arg1 arg2 ... argN; 
          parses file xxx, replacing %i by arg i 
          (max. args. = 32, arg 0 is file name) 
 
RUNC
    Run a C-script (allowing calls to TNT and access to TNT internal  
    variables). This uses the C-interpreter from "PicoC":  
       (c) 2009-2011  Zik Saleeba, https://gitlab.com/zsaleeba/picoc 
       (c) 2015 Joseph Poirier https://github.com/jpoirier/picoc 
    A lot of added functionality concerns specifics of phylogeny and 
    connection with TNT.  The work for this was done in collaboration 
    with Martin E. Morales; if publishing results or scripts, please 
    cite https://doi.org/10.1093/bioinformatics/btaa214. 
    Options: 
      filename  run script "filename" (starting from "main()") 
                If "exit()" used to terminate script (returning 
                control to TNT), exit status is written to  
                variable "exstatus". From "main()", "return" 
                goes back to TNT but does not set "exstatus". 
     [N         keep track of up to N simultaneous memory allocations 
                (with "malloc()", "calloc()", "realloc()", or "free()") 
                within script execution, and automatically free all 
                tracked memory when exitting script.  Default N=5000. 
                If N=0, then memory is not tracked and freeing memory 
                is entirely up to user.  Keeping track of allocated memory 
                incurs in a small overhead (memory and time), but makes 
                scripts simpler. 
      +name     list TNT functions matching "name"; if no name provided, 
                list all functions and reserved words 
      =lib      list functions/expressions available in library "lib" 
                (if no library given, list available libs), with a  
                description of TNT library functions 
      ! ... !   Read script ("...") from console or TNT input file; end 
                script with a line starting with "!".  No "main()" 
                must be included in script.  This is  useful to test 
                functions or small scripts, or to embed portions of 
                C-code in a TNT instructions file. If reading from console, 
                note that execution begins only once the full script is 
                read (i.e. after reaching the ending "!") 
    All libraries are included automatically, so there is no need to use 
    any "#include" directives for standard libraries in scripts. The 
    stack size for the C code is by default 512 Kb; this can be changed 
    by defining an environment variable "STACKSIZE" prior to running 
    the script. 
    N.B. if "main()" receives arguments, the second one should be set 
    as "double char pointer" (e.g. char ** argv) instead of "single char 
    pointer" (i.e. char * argv[]), which is not supported. 
 
SAVE
    save trees to file (previously opened with "tsave") 
    N    save tree(s) N. 
    /    save last tree in memory 
    *    save tree-tags in parenthetical notation 
         (tree-file must be parenthetical) 
    -    save trees numbering only active taxa 
         (in combination with xread-, saves reduced 
          trees). 
 
SCREEN
    NxL   use screen of N lines and L rows 
 
SCORES
    N   calculate tree-scores (length or fit), for tree(s) N 
    !N  same, optimizing polytomies as "soft" 
    &   same, calculating likelihoods with Mk model 
        (only for discrete caracters; if DNA/protein data 
        present, treated as if morphological). 
    |   same, calculating likelihoods with the Implik model 
        of Goloboff & Arias (2019). 
 
SECTSCH
    Do sectorial-search, starting from pre-existing trees. Options are: 
    For determining choice of sectors: 
      rss          do random sector selections 
      css          do constraint-based selections 
      [no]xss N+R  do N exclusive (i.e. non-overlapping) sector selections, 
                   covering all tree, and analyze each; repeat process R 
                   times or rounds (after the last one, do global TBR). 
                   If R is followed by -G, then global TBR is done every 
                   G rounds (and after last one).  Using B-E instead of N 
                   division starts at B and ends at E (increasing or 
                   decreasing, depending on whether E>B or B>E) 
      dss N D      select nodes around node N, up to D (=diameter) branches 
                   away from N, and analyze sector.  This requires specification 
                   of a tree; it never swaps at the end (as in noglobal) 
      [no]xeven    for exclusive sectors, [don't] use sectors of as even 
                   a size as possible (uneven sectors make it more likely 
                   to find better trees if using several rounds 
      minsize N    minimum size for random selections 
      maxsize N    maximum size for random selections 
      minfork N    minimum fork for constraint-based selections 
      maxfork N    maximum fork for constraint-based selections 
      increase N   factor to increase size if enough selections of current 
                   size completed. New size is S = S + ( ( S * N ) / 100 )  
      selfact N    factor to determine (under random selections) maximum number  
                   of selections of size S, for T (active) taxa.  Maximum 
                   number, M, is determined as M = ( T * 100 ) / ( N * S ). 
                   Alternatively, using "selfact = X Y Z" uses X for the 
                   first selection, Y for the second, and so on (up to 30 
                   values can be defined) 
      moveon N     if N selections fail to produce a better score, move on 
      rounds N     for constraint-based selections, cycle N times over groups 
    For determining analysis: 
      global N     for smaller selections, do global TBR every N replacements 
      dglobal N    same, for larger selections (i.e. under drift and combined) 
      noglobal     never swap globally. 
      [no]equals   accept equally good subtrees 
      [no]fuse N   when analyzing small sector (below drift size), keep 
                   all trees and fuse (N rounds).  Note: for sectors above 
                   drift size, the autofuse option of drift applies. 
      godrift N    sector size above which tree-drifting (not RAS+TBR) is used 
      drift N      for drifted sectors, use N cycles of drift 
      gocomb N     for sector of size N or more, use combined analyses 
                   (RAS+drift+fuse).  If N is smaller than the size to 
                   use drift, drift is not done.  Number C of drift cycles 
                   for each start is determined with drift C, number F of 
                   fuses is determined with fuse F. 
      starts N     for sectors below minsize, number of randaddseqs plus TBR 
      combstarts N for sectors above size for combined analyses, use N starts 
                   (if first N yield same score, stop, else do N more starts) 
      findscore N  stop drifting on tree if score N found 
      [no]keepall  keep only the best trees [don't] 
    General options: 
      [no]safesank for sankoff characters, use strict checking (=default) 
                   to identify uninformative characters for reduced data set 
                   (looser checking may produce small speedups, but may miss 
                   better trees for complex transformation costs). 
      slack N      make N percent extra memory for searches (prevents 
                   memory errors during runs 
      [no]xbuf     if memory is available, use independent matrix-buffer 
                   for analysis of sectors (=faster updates, significant 
                   time saved for small sectors in large data sets). 
      recurse N    allow sectorial searches to recurse up to N levels 
      tree N       select sectors for tree N (instead of all trees) 
      track        allow tracking nodes between big tree and reduced 
                   tree (valid only for sectorial searches with user 
                   instructions).  This is to be used in combination 
                   with macro expressions "nodtosect", "biginsect" 
      chkroot      for XSS searches only, make sure the base of tree (which 
                   often may be unselected) is included as well; this may 
                   actually use one more selection than requested. 
                   and "bignotsect".  A slave running a sector (see 
                   under "ptnt") always allows tracking. 
    Options are set with "sectsch:options;" or "sectsch=options;" (using 
    ":" only settings are changed; "=" runs as well). With "sect:;"  
    current settings are displayed. 
       It is also possible to determine specifically how to search for 
    each sector generated, including the commands to search within square 
    brackets (including sectsch itself, possibly with user instructions as well). 
    Maximum level of recursion has to be determined with "sectsch: recurse N;" 
    before reading data set.  When using user instructions for each sector, 
    any settings changed for analyzing a subproblem will remain changed after 
    concluding analysis of the sector (the only exception to this is settings 
    for sectsch itself). 
 
SHORTREAD
    xxx     read trees (compact) from file xxx 
    =N xxx  same, but place them in group N 
    >N xxx  same, but add them to group N 
 
SHPCOMP
    Comparisons of tree-shapes, between two trees.  It re-labels taxa in  
    one of the trees, so as to maximize the tree similarity without changing 
    tree-shape. The re-labeling algorithm is a heuristic, so repeating 
    this with  different random seeds may produce different results. 
    It works well for trees with up to 50-60 taxa, it starts to fail 
    (producing suboptimal re-labelings) for larger problems. 
       Please note!  This command is experimental and not very efficient; it 
    may be replaced in the future by better algorithms. It is intended only as 
    a proof-of-concept implementation. 
    Options: 
       X Y xJ K L   relabel tree(s) X and Y, with J starting points, of K  
                    cycles and L rounds each.  It tries to optimize the sum of  
                    steps of the MRP of each tree mapped onto the other. 
       +X Y xJ K L  same as above, but trying to optimize Robinson-Foulds  
                    distance 
       =            save the labeling that optimizes MRP or RF (i.e. change 
                    the trees). 
       X *N         randomly switch labels between two taxa in tree X, N times 
       X !          randomly rearrange terminal labels in tree X (according to  
                    current random seed). Using a second "!", preserve location 
                    of outgroup taxon. 
 
SILENT
    Control output to xxx: 
       =xxx;    no output to xxx. 
       -xxx;    output to xxx. 
    "xxx" can be "all," "file," "console," or "buffer." 
 
SLFWT
    Set parameters for auto-weighted optimizations (defaults in 
    square brackets): 
        exops N        for characters with more than N states, 
                       pre-check transformations and forbid those 
                       not occurying under a lineal optimization. [5] 
        timeout N      use no more than N seconds to calculate 
                       optimization for any given character. [3600] 
        tolerance N    accept reconstructions that differ from 
                       optimal in N units of score. [0.0000001] 
        [no]polymorph  during optimization, [don't] consider polymorphic 
                       taxa as having a missing entry (=faster). [don't] 
        errmargin N    during searches, re-check trees that are within 
                       N units of fit above best score. [0.5] 
        [no]autotune N during searches, compare estimated and actual  
                       scores of new trees, updating error margin 
                       With N=1 (=level 1), error margin is changed only 
                       within a given swapping cycle; with N=2, error 
                       margin is retained after swapping [level 1]. 
        maxtbr N       during searches using TBR, reroot clipped clade 
                       no more than N nodes away from original rooting 
                       (maxtbr 0 = SPR). [5] 
        setlim N       restrict possible state-sets during optimization 
                       for characters with N states or more. [4] 
        maxdist N M    when restricting possible state sets, use union 
                       of states in branches up to N nodes away above a 
                       node, and M nodes below. [6-3] 
        [no]useminset  when restricting possible state sets, use a set 
                       corresponding to optimization under prior costs 
                       (very fast, very prone to errors. [don't] 
        maxrepeat N    when N successive branches have the same (unique) 
                       state, consider them as fixed. [8] 
        [no]quickrat   under this criterion, producing very few optimal 
                       trees, ratchet and drifting tend to find (and 
                       thus swap) the same tree many times; with this 
                       option, when the tree resulting from the perturbation 
                       phase of ratchet/drifting has the same score as the 
                       best tree(s) found so far, the tree is not swapped 
                       (this is applied only when auto-wt is ON). [yes] 
        backbuf N      back up N pre-existing trees during swapping; 
                       in case a tree is re-found, swapping is interrupted 
                       (prevents cycling due to score miscalculation; 
                       0 is no buffering). [0] 
        [no]verbose    as characters are optimized, report progress. 
 
SLAVEPROC
    reserved for use by parent process, in parallel TNT 
 
SMATRIX
    =N (name) [costs] 
        defines a step-matrix.  Syntax for costs is as in 
        "cost" command.  N must be a number 0-31.  Name is optional.  
    +name N 
        apply step matrix of specified name to character(s) N 
    ;   show defined step matrices 
    *   save them (to read, must set "nstates / num;") 
    &   Produce a Sankoff approximation to inapplicables. 
           [ N.B. this option is now superseded by the "xlink" option,  
             which is way more flexible. The "smatrix&" option is kept  
             for backwards compatibility. If you enable links with  
             "xlinks=2" (or more) prior to reading the dataset, then 
             "smatrix&" converts the subordination into "xlink" format 
             internally, which can also be saved for subsequent use (see  
             "help xlinks") ] 
        With the "smatrix&" option (and "xlinks" disabled), characters 
        named "sub_xxx", are considered as subordinate to one 
        named "sup_xxx" (name of subordinate character may be longer 
        than "xxx", but must start with "xxx" to establish identity). 
        The matrix entries in the "sup_" character (which must consist 
        only of states "present" and "absent") are changed to now 
        have combinations of qualities; transformation costs are changed 
        (so that changes between "present" states cost as much as the 
        differences between the qualities, taking into account costs, if 
        Sankoff, or additivities otherwise). State names for the "sup_" 
        character, as well as transformation costs, are also changed. 
        There are limits to the number of states than can be generated 
        (max. is 32), and the superordinate and subordinate characters 
        must be concordant (e.g. a taxon scored as "absent" or "missing" 
        for the superordinate cannot be scored with anything other than 
        "missing" for a subordinate). Ambiguities in subordinate  
        characters are properly handled. See "usminmax" command for 
        options to handle unobserved combinations of states. Character 
        weights are taken into account; if weight ratios between super/ 
        subordinate characters are not exact, this is done by means of 
        appropriate transformation costs instead of weights (note this 
        affects implied weights!). A character that is "sub_" to some 
        other, can in turn be "_sup_" of a third, creating multiple 
        levels of dependence, taken into account when recoding. 
        Example names: 
 
              sup_post_legs absent present 
              sub_post_legs armed unarmed  
              sub_post_legs scaly hairy 
              sub_post_legs_sup_apophysis absent present 
              sub_apophysis spinose aspinose
 
              Which define the hierarchy:
 
              post_legs                     absent  
                /     \                    /  
              absent   present -- apophysis  
                         /   \            \  
              scaly,hairy  armed,unarmed    present   
                                                \  
                                             spinose,aspinose
 
        The hierarchy is automatically incorporated into the costs of  
        main character ("post_legs"). The costs are set so that 
        independent transformations into the recoded "state" cost 
        as much as the number of similarities that are not then 
        accounted for by homology; this is what produces results  
        closests to those of "anagallis". In the case of multiple 
        levels of dependence, this means that some gains in the main 
        character cost more than others --in the example above, 
        gaining "post_legs" that have an apophysis will cost 5 
        steps; gaining them without an apophysis will cost only 
        4 (as the features of the "apophysis" itself then don't 
        apply). Note that in the case of Sankoff/additive dependent 
        characters the results of the recoding will deviate more  
        strongly from those of maximum homology (i.e. anagallis); the 
        recoding produced is only an approximation. The correspondence 
        is closest when all characters are binary/nonadditive. 
        Keep in mind that the combined character cannot exceed 32 states 
        (exceeding the 32 states triggers an error message). In that 
        case, either combine fewer characters, or try programs  
        with algorithms specifically designed to handle inapplicables 
        (such as De Laet's program "anagallis", or Brazeau's "Morphy" 
        (found at www.anagallis.be/anagallis, www.morphyproject.org). 
    &+  like previous one, but calculate minimum possible number of  
        steps with a search, instead of sum of minima for the 
        individual characters (achievable only if there is no conflict 
        between the dependent characters themselves!). 
    &<  like previous one, but if dependent additive characters present, 
        instead of treating them similarly to anagallis (=default), set 
        gain cost as the minimum possible to preserve triangle inequality 
    |   if  subordinate and superordinate characters have been modified 
        with "&", set matrix (and costs) back to original. 
    <   ban unobserved states from being considered at ancestral nodes 
        (by giving transformations to/from them a cost of 1000, presumably 
        "impossible"). 
 
SORT
            sort tree(s) in RAM, from best to worst 
    =nodes  instead of sorting by score, sort by number of nodes 
    =size   sort by number of taxa 
    =mono   sort by number of violated constraints 
 
SPRDIFF
    J K NxS  estimate number of SPR-swaps required to convert tree 
             J into tree K.  The method used is heuristic, depending 
             on random seed.  It does N replications, and reports  
             best estimation (if no N specified, then N=10); each of 
             the replications uses a "stratification" of up to S 
             levels (default S=0). Depending on the tree topologies, 
             the stratified procedure (more time-consuming) produces 
             better estimations. Using N+S instead of NxS, stratified 
             and regular procedures are alternated (keeping the best 
             overall values at the end).  If one (or both) of the  
             trees have polytomies, then the distance is calculated 
             (by default, see below) between the closest dichotomous 
             resolution(s). The "similarity" is number of moves  
             divided by number of taxa - 3 (i.e. max. possible moves). 
    *J K NxS estimate SPR-swaps and show moves on tree diagrams 
    [K;      count moves as weighted, with a move to D nodes away 
             costing D/(K+D).  As K decreases, approaching 0, all 
             moves cost the same; as K gets larger, longer moves are 
             more costly.  For reporting values, they're rescaled so 
             that the farthest possible move (nt-3) has a cost of 1. 
             Note that "[K;" only sets the value and type of compa- 
             risons to do in subsequent calls to "sprdiff" (or calls 
             to relevant macro expressions), without running. 
             Similarity is also obtained by dividing from number of 
             taxa minus 3 (i.e. max. possible number of farthest 
             possible moves, each of cost 1). The distance D of a 
             move equals degree of the polytmoy created when consen- 
             sing the trees before and after the move, minus 2. 
    ];       in subsequent calls to "sprdiff", count raw moves. 
    It is also possible to search for SPR paths such that no move  
    has a node connecting to one of its ancestors (if the SPR path 
    is to be interpreted as indicating horizontal gene transfer, 
    such moves constitute a physical impossibility). For this, use  
    ": noviol;" as argument ("viol" would allow such moves). 
    If you wish to count the moves needed to resolved/collapse 
    the polytomies of the tree(s), if any, then use ": poly;" 
    (keep in mind that this count is approximate!); default is 
    ": nopoly;". Alternatively, with ": halvepoly", you set 
    the cost of collapsing/resolving moves to half (thus making 
    distance from a binary tree to a bush 0.5, not 0 (in "nopoly") 
    or 1 (in "poly"). 
 
SUBOPT
    NxR   set suboptimal to N, relative suboptimal to R (note: relative 
          suboptimal is measured against tree being swapped, not against 
          best tree(s) found).  Values of suboptimal used for subsequent 
          searches, or when collapsing trees with SPR or TBR. 
    :T/P  same as in "bsupport". 
 
SVTXT
    J K  save text-buffer lines J to K to output file (default = all) 
 
SYSTEM
    xxx<enter>  run xxx in system 
 
TABLES
    =   use optional table format 
    -   use default table format 
    /N  use N significant digits for floating point values (default=2) 
 
TAGSET
    N;  set tag to N (parallel versions only) 
 
TAXCODE
    -N;   de-activate taxon with number/name N (no N: show inactive taxa) 
    +N;   activate (no N: show active taxa) 
 
TAXLABELS
    N      report name of taxon N 
    xxx    report number of taxon named xxx 
 
TAXONOMY
    Handle taxonomy contained in the taxon names, in GB->TNT format 
    (i.e. symbol "@" followed by the categories, separated by under- 
    scores). 
      =     for subsequently read data sets, incorporate taxonomy 
      -     don't [ =default, uses less RAM ] 
      ;     if taxonomy has been incorporated, display it as a tree 
      /     display taxonomy as an indented list 
      ]     contract taxonomy, eliminating redundant categories 
      +     store taxonomic tree as last tree in RAM 
      *T    label branches of tree(s) T which correspond to a taxonomic 
            group; extraneous taxa added to the group are indicated 
            as "+", taxa excluded as "-".  The criterion for  
            choosing closest group in tree (if any) is determined as 
            for "prunmajor" and "rfreqs" commands.  The tree list can 
            be followed by a list of categories, in the following format:  
                /L X-idae Z-idae 
                    processes X-idae and Z-idae (with L levels within) 
                    If L is followed by ">N", only subgroups of size N  
                    or more are further subdivided 
                \L B-morphae  
                    processes the subdivisions of B-morphae, up to L levels 
                    below B-morphae.  If L is followed by ">N", only groups 
                    of size N or more are further subdivided 
                =xxx   
                    processes all the taxonomy categories containing "xxx"; 
                    if you want to make sure that "xxx" occurs at the end 
                    of the category, add an underscore (i.e. "xxx_"). 
            The options "/", "\", and "=" can be combined. 
            If you prefer the stats to not be output for monophyletic groups, 
            use "**" instead. To skip stats for all groups, use "*-". 
      &T    as previous one, but results are output as a list.  The tree list 
            may be optionally followed by a list of the categories to report 
            (default=all; note categories are referred to by name, not number, 
            since numbering is only internal to TNT; the numbering follows 
            that on the taxonomic tree).  The command may end with "> A S", 
            where A and S are numbers of taxon-groups where to place taxa 
            added to the group, or subtracted from the group respectively, that 
            need to be removed to make the group monophyletic. Note that if the 
            symbol "&" is immediately followed by "?", then TNT asks  
            confirmation before placing taxa in groups. 
      !T    outputs a list, as previous one, but also adds a verbose description  
            of the exceptions to taxonomic groups.  This can be done for a single  
            tree, and cannot save to groups the taxa added/subtracted for each 
            group.  Using a double "!" also reports the positions of members 
            of groups not found in the tree (may be more space-consuming!). 
      |     similar to previous one, but only reports best/worst cases (instead 
            of reporting tree-by-tree stats), and output list is indented. 
      <T    shrinks the groups specified as in previous one (a single tree must be 
            specified in this case) 
      :T    color tree-branches for specified groups, on tree(s) T  
            For each tree colored, the colors are stored in tree-tags, which 
            can be saved in SVG format with "ttag & filename colors" 
            Each group to color can be given as:  
                /X-idae Z-idae  /A-idae  /B-morphae  
                    colors X-idae and Z-idae as state 0, A-idae as 1, and so on 
                    (the option to include a number of sublevels is ignored here, 
                     you must use "\" instead) 
                \L B-morphae  
                    colors the subdivisions of B-morphae, up to L levels below 
                    B-morphae, each with a different color.  If L is followed by 
                    ">N", only groups of size N or more are further subdivided 
                =xxx   
                    colors all the taxonomy categories containing "xxx", 
                    each with a different color 
            The options "/", "\", and "=" can also be combined. 
 
TAXNAME
      =          when referring to terminal nodes, use names 
      -          don't (=default) 
      /XXX N     rename taxa N as XXX (if XXX is *, rename at random; 
                 if XXX is > or <, switches name to upper or lower 
                 case, respectively). If XXX is -, it "denames" taxa 
                 in list N (i.e. makes their name a blank space) --this 
                 can be used to plot trees with no taxon names. 
      +N         allow taxon names of length N 
      [N         on output, truncate taxon names to N letters.  Use "!" to 
                 truncate to species only (i.e. to "@" or cuadruple-underscore) 
      ]          don't 
      :T =G      re-locate list of taxa T in taxonomic group G.  This changes taxon 
                 names and re-processes taxonomy.  Optionally, group G may be  
                 followed by "+ _Supergroup_Group_Subgroup" --case in which 
                 the specified categories are added to the newly located taxa; 
                 or it may followed by "=C" or ">C", case in which all  
                 categories beyond "C" in the relocated taxa are preserved 
                 (exclusive, or inclusive, respectively).  The latter amounts 
                 to transferring an entire group (with its sub-classification) 
                 to a different higher group. 
 
TCHOOSE
    N   select tree N (use scopes, + and -) 
    /   select last memory tree, discard the rest 
 
TCOMP
    M N/L     show groups in tree M absent from N, excluding taxon (taxa) L 
    *M N/L    same, keeping tree as last memory tree 
    [         show only compatible groups 
    ]         show only contradictory groups 
    =N/M/L    calculate RI resulting from mapping the MRP of each tree 
              in set N onto each tree of set M, excluding taxon (taxa) L. 
              Note this is NOT equivalent to =M/N/L (RI is asymmetric). 
              The RI is calculated by adding an external root, so that 
              the comparison is rooted (i.e. different rootings of the  
              same trees produce different values; same is true for the 
              next two types of comparisons). 
    ==N/M/L   like previous one, but make G and M (maximum and minimum 
              steps) the sum of both MRPs, and S the sum of steps of each 
              MRP mapped onto the other tree.  This IS symmetric. 
    =!N/M/L   like previous one, but make G the maximum for two pectinate 
              trees (which have the maximum G). With this, a bush is "in  
              between" binary trees, rather than most distant. 
              MRP mapped onto the other tree.  This IS symmetric. 
    <N/M/L    calculate Robinson-Foulds distances from each tree 
              in set N to each tree of set M, ignoring taxon (taxa) L. 
              Using ">" instead of "<", it does a "rooted" distance. 
              For trees with T taxa, this is normalized by 2x(T-3) for 
              unrooted, and 2x(T-2) for rooted.  To normalize by number of 
              groups actually present (i.e. so that distance between a bush 
              and a binary tree is 1, not 0.5), use a double ">" or "<". 
    :N/M/L    calculate tree-distances, similar to Robinson-Foulds 
              distances but using degree of recovery (as in "prunmaj" 
              and "rfreqs") for each group instead of just abs/pres. 
              Settings to calculate degree of recovery set with "prunmaj". 
              Distances are from each tree in set N to each tree in set M, 
              ignoring taxa in list L.  This is a symmetric measure. 
              This is normalized by groups present in the trees; to normalize 
              by number of groups in two resolved trees, use "!" after ":". 
    &M N/L    plot tree N, showing for each group the equivalent group in 
              tree M (if none, "X"). 
    ! T/L     report PCR values (Pol & Escapa, 2009) for tree(s) T, taxa L. 
              if "=N" precedes list of taxa, then it reports worst N 
              values.  Using ">G" at the end, it puts listed taxa in 
              taxon-group G. 
    !! T/L    similar to previous, but instead of PC it reports Thorley 
              and Wilkinson's LSI stability index (average difference 
              between first and second most frequent resolution of the 
              triplet, for all triplets containing each taxon). 
    &         only after "!": when finding that a triplet is present  
              in all trees, try to combine with previously checked  
              triplets to infer resolution of triplets not yet checked. 
              Faster for larger numbers of trees, differing in fewer 
              taxa 
    @N/M      Calculate Smith's (2020) distance measure, "Cluster 
              Information Distance", from every tree in set N to every 
              tree in set M. Trees are not temporarily collapsed and  
              no taxa can be ignored (use the "condense" command to  
              collapse them prior to calculating distances, possibly  
              removing some taxa). If "@" is followed by "!", then 
              measure is rescaled by reference to the entropy of two 
              pectinate trees (i.e. a fixed reference for rescaling). 
    |N/M/L    Calculate values of Observed Success of Resolution (Simmons 
              and Webb, 2006), rescaled as in Simmons et al. (2023), from 
              all trees in set N, to trees in M, ignoring taxa in list L. 
    (N/M      Calculate triplet distances (similar to quartet distances, 
              but fewer triplets than quartets!), from all trees in set 
              N, to all trees in set M. Note that this requires trees 
              rooted on the same terminal. The code for calculations 
              is not especially efficient, and can be slow for large 
              datasets (it has dependency O(T^3)). This is the number of  
              triplets resolved in any of the trees that are false in 
              the other, divided by the sum of the number of triplets 
              resolved in each tree. The rescaling with number of 
              resolved triplets makes the distance between a binary tree 
              and a bush maximum. 
    )N/M      Like previous one, but skip rescaling, outputting absolute 
              numbers. Note that the numbers of false triplets are  
              counted differently from other implementations of triplet 
              distances. E.g. this counts two false triplets between  
              (A(B(C(DE)))) and (A(B(D(CE)))), but a single one between 
              (A(B(C(DE)))) and (A(B(CDE))). In contrast, the much faster 
              algorithms of Sand et al. (2014, doi:10.1093/bioinformatics 
              /btu157) would count a single false triplet for every pair 
              of trees. Using "!" after the ")", TNT counts as with 
              Sand et al.'s algorithm (i.e. 1 between each pair of trees). 
    (!N/M     like the previous one, but rescaling by twice the total 
              number of possible triplets. With this, distance from a 
              binary tree to a bush is 0.5 (i.e. as in the standard 
              rescaling of the RF distance). 
    Note that only the first four options (default, *, [, and ]) use 
    temporary collapsing of unsupported groups. 
 
TEQUAL
    Show duplicate trees 
 
TFUSE
    /S C T; create a new tree from trees S ("source") and T ("target") 
            inserting clade C of tree S into equivalent position of tree T 
            (clade C must be present in both trees; trees must be complete 
            and binary) 
    N   combine set of trees N, and add resulting trees to existing set of 
        trees. 
    Options (possibly preceded by "no" and defaults in parentheses):  
    For tree-fusing: 
       [no]equals       accept exchanges of equal score (don't) 
       [no]beststart    use best tree to start (use it) 
       [no]choose       choose only those exchanges that improve best score 
                        found so far (don't) 
       [no]repeat       for every individual fuse, re-fuse trees until  
                        no exchanges improve it 
       [no]swap         after exchanging clades, do TBR swap (swap) 
           minfork N    if node is less than an N-polytomy in consensus of 
                        both trees, skip exchanges (3) 
           rounds N     use N rounds (5) 
       [no]keepall      keep all trees found instead of best only (all) 
       [no]xroot N      for each fuse, try N different (random) rootings 
                        (N=0 is the default; it uses only outgroup as root) 
    For tree-hybridization: 
       [no]hybrid N*R/S instead of tree-fusing, use hybridization (as in  
                        "hybrid" command).  Hybridize randomly chosen pairs 
                        of trees, N times, for each round R.  Every round uses 
                        the best S trees from previous round to continue hybri- 
                        dizing.  Defaults: N 1000, R 1, S 50 (S = 0 uses as many 
                        trees as initially input, when doing several rounds.   
                        Works better than fusing for very unstructured data sets 
                        (e.g. random). 
       [no]autostop N   if N successive rounds of hybridization fail to improve 
                        score, stop (default = 3). 
       [no]replace      if hybridizing two trees produces a better tree, then 
                        replace source tree(s) with the better tree(s) 
                        (default = yes). 
       [no]clog N       If initial tree set increased to contain N times more 
                        trees than the initial input, retain best 1/N trees 
                        (default = 15). 
    For selecting type of genetic algorithm: 
       [no]picktype N   calculate a score for the expected outcome of fusing; 
                        this score counts the proportion of groups that could 
                        be exchanged between different pairs of trees in the  
                        input trees (when few or no groups can be exchanged,  
                        as is often the case for random data sets, tree-fusing 
                        produces very poor results). If the score so calculated 
                        is above N, use fusing, if below, use hybridization. 
                        The default is "nopicktype"; if "picktype" specified 
                        without a number, it uses the default threshold (1.5) 
                        Large thresholds preferentially choose hybridization, 
                        and viceversa. 
    Options are set with "tfuse:options;" or "tfuse=options;" (using 
    ":" only settings are changed; "=" runs as well). With "tfuse:;" 
    current settings are displayed. 
 
TGROUP
    Define group(s) of trees 
    Usage: 
         "tgroup =N (xxx) J [K L M] len=X nod=X siz=X mono *R;" 
    places in group number N, optionally named "xxx," the tree(s) 
    subsequently specified with J (tree(s) number J), or in group(s) 
    K and L and M, or having a length, number of resolved nodes, or 
    terminals included, equal to X, or satisfying constraints, or R  
    trees chosen at random.  Symbol = can be replaced by > or < in  
    the case of len, nod, or siz. If a range of trees is followed by 
    "/Z", the list includes every Zth tree between first and last 
    tree in range. If the first option, =N, is replaced by >N or <N, 
    subsequently specified trees are added or removed from group N. 
    Several =N (or >N or <N) can follow a command; every one takes 
    into account previous ones.  Subsequent to definitions of tree groups, 
    group(s) of trees can be identified within scopes by referring to them 
    enclosing the group number/name in curly braces.  By default, trees 
    read or calculated are placed automatically in groups; this can be 
    toggled with "tgroup/;".  The definition of the last group  
    automatically defined can be changed by substituting the number  
    of group (N) with / (i.e. with =/, >/ or </).To undefine group N, 
    use "tgroup -N;". Saving current groups is done with "tgroup*;". 
    The default maximum number of tree groups is 32, but can be set to 
    N with "tgroup+N;" (this must be done prior to reading the data). 
    Whether newly read or created trees are automatically added to tree 
    groups is toggled with / (default is on), or set to a specific value 
    with "tgroup [no]auto". 
 
THANKS
    show acknowledgments 
 
TIMEOUT
    set timeout for searches (hh:mm:ss) 
    In Linux versions: if running in the background, creating a 
    file "stop_tnt_ID" in the working directory automatically 
    sets the timeout for searches to 1 sec., thus interrupting 
    all searches. 
 
TNODES
    N   count nodes in tree(s) N 
    *N  display list(s) of forks in tree(s) N 
 
TPLOT
    N    show tree(s) N. 
    *N   show tree(s) N in parenthetical notation. 
    /    show only last tree in memory 
    +    draw trees more symmetrically (they're taller!) 
    -    draw trees with default format 
    :xxx when showing trees, zoom at node labeled as xxx 
         (xxx can also be a number). Use "tplot:;" to 
         undefine) 
    =    define margins for saving trees in SVG format. 
         The "=" symbol can be followed by up to four 
         values: left, top, right, bottom margin (i.e.  
         clockwise, starting at left margin. You can also 
         indicate any single value with <, /, >, and \ 
         the same sequence). 
    If + or - are followed by + or - this turns on (+) 
    or off (-) whether second heaviest clade is drawn 
    first in polytomies. 
 
TREAD
    read tree(s) in parenthetical notation; semicolon ends; 
    '*' separates trees.  Using "=N" (or ">N") as first argument, the 
    trees are placed in (or added to) group N. 
      The tree-definition can be done using taxon names or numbers 
    (if using a name, the first taxon matching the name is used). 
    Alternatively, a string followed by three periods (no spaces in 
    in between) will place in the corresponding location all taxa 
    whose name matches the string provided.  Also, using @T N will 
    place all the taxa that belong to node N of tree T in the corres- 
    ponding location.  Using a + instead of the @, the sub-tree N 
    of tree T is copied (and then this is just one node, so make 
    sure you don't enclose +T N within parentheses, which causes an 
    error). 
    Other options for "tread": 
      [     when subsequently reading tags from a parenthetical tree, 
            add the tags to any existing tags. This can be used to 
            easily concatenate multiple tags. If the "[" symbol 
            is followed by anything other than ";", then that  
            character is used as separator; use "&N" for ASCII char 
            N as separator. This separator is then used for normal 
            concatenation of tags (i.e. with tree-drawing commands); 
            use N=0 or N=1 for no separator. If the tree being  
            read is different from the tag-tree, the new labels  
            are added to the corresponding groups, and labels for  
            groups that don't exist in tag-tree are lost. By  
            default, different taxon sets are treated so unshared  
            taxa are ignored [e.g. if the current tag-tree is 
            (A(B(C(DE)))) and the new tree is (A(B(CD))), the label  
            for group CD in new tree is added to label for group 
            CDE in tag-tree]. This can be changed with "unshared-" 
            (in which case label for group CD in new tree is lost) 
      ]     don't (=default) 
 
TSAVE
            open tree files (with + at the end, append) 
    xxx     open in compact (default) mode 
    *xxx    open in parentethical notation, using taxon names 
            or numbers (see under "taxname") 
    /       close tree file 
    =       open file, save trees now in memory, and close file 
            (works for both compact, or parenthetical) 
    !t xxx  autosave results to file, every t seconds (t can be given 
            as hh:mm:ss).  For maximum safety, results alternatively saved 
            to files xxx-1 and xxx-2 (if power fails when saving, the 
            previous one remains). 
 
TSHRINK
    Define groups of terminals to shrink tree. Usage: tshrink =N name list ; 
    Replacing N by "+" names next available group of taxa.   Symbols  
    "]" and "[" deactivate/activate subsequently specified shrinks; 
    symbol "-" undefines them.  "Tshrink*" saves subsequently specified 
    tree(s) in parenthetical notation, but shrinking internal nodes. 
    Shrinks may use a lot of memory (specially in large data sets).  If 
    you want memory for shrinks to not be allocated, use "tshrink !;" 
    before reading the data set ("tshrink +" will allocate the memory). 
 
TSIZE
    N   count number of taxa included in tree(s) N 
 
TTAGS
    Handle tree-tag settings. Note that specific tag separators can be 
    defined with the "tread" command. 
    ;       show tree tag(s). 
    |       same, but displaying multiple lines as such in text trees 
    =       store tree tags for subsequent tree printing command(s) 
            (first tree printing command sets the target tree) 
            N.B. If tree and tags stored already, and macros are ON, this  
            can be followed by "<ray" or ">ray". First case sets 
            the tags to the values stored in array "ray"; second case 
            sets values in the array to the values in the tags (tags 
            must be numbers!). Using "<<" or ">>", negative numbers 
            between -1 and -5 are interconverted with symbols "-", "Y", 
            "N", " " (blank), and "X". Using "[" instead of 
            "<", it copies only to internal branches. Instead of printing 
            the values contained the array, it is also possible to print 
            the state names of character C, with "<&C ray" or "[&C ray" 
            (this may greatly facilitate showing specific mappings of a 
            character on a a tree, e.g. in conjunction with "iterrecs"). 
    (       synonym of "=" 
    )       stop storing tags (but don't erase them) 
    -       clear all existing tags 
    +N txt  write txt to node N of target tree 
    >XXX    Change title of tree-tags to XXX 
    <N      erase (i.e. reduce to a minimum) tree-tag for node N 
            Using a second "<" instead of N, erase tree-tags for 
            all terminal branches; with ">", the opposite 
    *N      set tree N as target tree (no labels written). Using 
            "!" instead of "N" the last tree is used 
            If N is followed by "<ray" (or "<<", as in  
            "ttag="), and macros or ON, then  it also sets the  
            tags from the values of the array "ray". Using "[" 
            instead of "<", it copies only to internal branches. 
    /;      save tags in a readable form 
    [       separate tags in new lines, using "\" as separator 
            for each legend (only in graphic trees).  If followed 
            by a number N, then it sets N to be the maximum width 
            of text to be output in multiple lines (0 = no limit, 
            default). If "[" is followed by a, b, c or d, then it 
            sets the position of multiple line tags in graphic  
            trees (i.e. in SVG files), to be 'a'bove, 'b'elow, 
            'c'entered, or 'd'isregarded (height of labels not 
            considered). Default is 'c'. 
    ]       don't separate legends in new lines 
    !       if some multiple lines are empty, wipe'em 
    &xxx    save tree-tags as tree diagram, in SVG (Scalable Vector 
            Graphics, XML) format, to file "xxx".  File name  
            may be followed by: 
               blength N    branch span (width; if using "colors", and 
                            branch lengths indicated with :L, then used 
                            as factor for tree-width). 
               bheight N    branch height 
               thickness N  branch thickness N 
               colors       save as colors.  In this case, the color 
                            is determined by the first digit in the tree- 
                            legend; more than a single digit (or a non-digit) 
                            colors the branch as gray (=ambiguous).  A text 
                            can also be displayed, if the color code is  
                            followed by a forward slash and text. 
               fontsize N   use a font size of N.  Use "tfontsize" or  
                            "bfontsize" to control size of font in terminal 
                            taxa or in tree branches, respectively. 
               italics      ditto, for taxon names (use "bitalics" for branch 
                            legends) 
               pendwidth N  use a font of stroke N (=boldness) 
               txtsep N     if using multi-line legends, separate lines 
                            by N points 
               legup N      raise branch legends by N points 
               shift N      move whole tree N pixels to the right 
               xysave var   save coordinates of every node to variable "var" 
                            (must be a 2-dimensional array), and leave SVG file 
                            open, for subsequent additions of text or SVG  
                            commands (with "ttag&+", see below). File 
                            remains open until closed with "ttag&;". 
               caption xxx  use xxx as caption for tree diagram (copies until  
                            a semicolon found; last option for "ttag &") 
               extra X,Y    leave X,Y points below and to the right of tree 
               rotate       rotate diagram counter-clockwise 
            The resulting SVG file can be opened with any appropriate program 
            (including most web browsers: Firefox, Opera, Safari, Chrome). 
            Color codes (from 0 to 9) are red, blue, green, cyan, brown, pink 
            orange, purple, magenta, and yellow.  Instead of these color codes, 
            it is also possible to indicate RGB codes (in parentheses, separated 
            by commas, optionally followed by branch thickness:length, before 
            closing the parenthesis). You can use dashed lines, if the first 
            color in the RGB code is preceded by a "-". 
    &+      If an SVG file previously left open (with the "xysave" option of 
            "ttag&"), then add text or commands. Options are:  
               write  copy (as in "quote"), verbatim from input to SVG file 
                      Use this to insert SVG commands into file. 
               text   Insert text into SVG file (no need to remember SVG  
                      syntax!). Syntax is:  
                        ttag &+text x y (R,G,B,font size:stroke width) TEXT; 
                      if no RGB code indicated, use font size 12, stroke 1. 
               line   Insert line into SVG file. Syntax:  
                        ttag &+line x1 y1 x2 y2 (R,G,B,width); 
                      If R code negative, then line is dashed. 
               rect   Insert a rectangle into SVG file. Syntax:  
                        ttag &+rect x1 y1 x2 y2 (R,G,B,W) (R,G,B,Op); 
                      First RGB code indicates line color and width W,  
                      second one fill color and opacity Op. If not  
                      indicated, line black and no fill. If first R code  
                      is negative, then line is dashed. Opacity: a 0-100  
                      value (default 100) 
    See also help for "tread", for an option to merge tags from tree-files. 
    NB: thanks to Salvador Arias for showing me the SVG format! 
    NB2: If you wish to display a text in a specific color (with 0-9, IUPAC 
         codes for DNA, or RGB codes), then precede the text by a forward 
         slash and precede the slash by the color code. 
 
TVAULT
    If tree-vault set, place or retrieve trees from the vault 
       >L    place tree(s) in list L in the vault; number of trees 
             in vault increased, tree-group membership preserved. 
             Keep in mind that *name* of group can change or other  
             trees may be added to group (e.g. if subsequent tree-creating 
             commands overwrite it); only the number of group, and the. 
             membership of the vaulted trees is saved.  Using '/' instead 
             of L, it saves to vault the last tree in memory. 
       <L    get trees(s) in list L from the vault.  Using '/' instead of 
             L, it retrieves last tree from vault. 
       -     clear all trees from vault 
       *     display trees in vault, in parenthetical notation. 
       !     exchange trees (from standard memory buffer) and user-variables 
             This can be used to store tree(s) in a memory space that does  
             not go away when reading a new dataset, without the need to 
             save trees to disk. Syntax is: 
                 tvault !var > T ;  
             or  
                 tvault !var < T ;  
             first case copies from variable "var" (an array) to tree T 
             second copies from T to "var". If T specified as "/", it 
             copies to/from last tree in memory. If using ">" and no tree 
             specified, adds one tree to tree buffer. It is not recommended 
             that you change the array and then copy to tree buffer, but if 
             you do, keep in mind that a sanity check is done before copying 
             from "var" to tree, to make sure that:  
                  a) basal node is numbered as number of taxa  
                     in dataset (=Ntax) 
                  b) terminal taxa numbered from 0 to Ntax-1 
                  c) internal nodes other than root numbered  
                     from Ntax+1 to L (largest node) 
                  d) every internal node is the ancestor of 
                     two or more nodes 
                  e) the ancestor of Ntax equals largest node 
                     in the tree plus one (L+1) 
                  f) a terminal taxon not included in the tree 
                     has ancestor = 0 
             These (plus others) are the same rules followed by TNT to number 
             internal nodes. Node numbers in tree stored in memory may be 
             reset (so that they follow TNT's rules for node numbering, 
             enabling tree handling and comparison) 
    Note: tree-vault is set with "hold N/V" (where N = max. trees, and 
    V = vault size). 
 
TXTSIZE
    N     set size of display buffer to N Kb 
    ;     report buffer usage 
    =     set buffer to compressed mode (slower viewing; default) 
    -     set buffer to uncompressed mode (faster viewing) 
    /     report approx. amount of disk space needed for text buffer 
 
TZERT
    X Y  insert groups of tree X onto tree Y 
 
VIEW 
    xxx  view file xxx 
    +    auto-view text-buffer on 
    -    auto-view text-buffer off 
    ;    view text-buffer (text-buffer has all the output). 
         Arrow keys, and page up/dn move buffer 
         While in viewer: 
             -   up one line 
             +   down one line 
             o   up one screen 
             p   down one screen 
             e   end  
             h   home  
             l   left half a screen  
             r   right half a screen  
            ESC  exit buffer viewer 
         Pressing ":" followed by a string, searches for the  
         string in the text-buffer (& repeats). 
    See also txtsize, svtxt. 
 
VLINKS
    View character links (defined with "xlinks") 
    Options:  
      N;  Show definition of complex N (no N=all) 
      -;  Display only a brief summary of complexes. 
      !N  Show complex N, and its state correspondences 
          (a "complex" is the set of all co-dependent 
          characters, as defined with "xlinks"). If no 
          N given, all. With a second "!", it only  
          displays number of recoded states. 
      =N  For complex N, show the transformations costs 
          among all recoded states (if no N given, all). 
      >   Show the transformation cost between two recoded 
          states (X, Y) in complex N:  
              vlinks > N X Y 
          This displays all the original states for each  
          character in the complex. 
      <   Use this to find out into what number of state is 
          recoded a given combination of original character/ 
          states, for a given complex. Syntax is:  
               vlinks < N C1 S1 & C2 S2 & C3 S3 ;  
          if fewer characters/states specified than characters 
          in complex N, then several states can match. 
      /   Check whether all terminals obey the rules specified. 
          To save the taxa violating rules to a taxon-group, 
          use ">G" (which adds the taxa to taxon-group G). 
      |   For terminals that do not obey the rules, select a  
          character-state combination that obeys the rules (a 
          combination of states that passes the rules is selected 
          at random, based on random seed; different seeds may 
          make different selections). Only meant to provide a quick 
          fix --obviously, not recommended for real analyses! 
      \L  Check whether the HTUs in each of the trees in list L, 
          reconstructed as independent characters, violate the 
          rules defined with "xlinks". On the tree branches, 
          the number of the complex(es) for which the rules are 
          violated is indicated. N.B. this does not check terminals 
          (for which, use "vlinks/;"). If you wish to display  
          results as a table, instead of graphically on trees 
          (this may be easier if you have many trees!), use 
          "vlinks\\". To save to tree-group G the trees that 
          violate the rules, use ">G" after the tree-list L. 
      *   Save currently defined links to log file, so that 
          they can be subsequently read by TNT. 
      &   Show tables for calculating rates (default) or probabili- 
          ties of transitions between combinations (with "lset  
          prob;"), used in ML calculations (e.g. "mkmap" or  
          "scores&" commands, or scripting expressions "mklik", 
          "fixlik", &c). The symbol "&" can be followed by ":" 
          to indicate width of character/state columns (as :C:S). 
          By default, tables for all complexes are shown; a complex 
          number N can be specified with "&N" after the first "&". 
          Somewhat nicer tables (under "rates" only) can be drawn 
          with the "lset nopoorman" option. 
             If the "&" symbol is followed by "<", then TNT 
          checks whether resulting probabilities for the complex 
          are time-reversible (i.e. checking whether detailed  
          balance equations are satisfied, for a range of branch 
          lengths). Inapplicable characters generally are, other 
          types of interaction generally aren't. 
             If the "&" is followed by a branch length, the table  
          is used to calculate the actual probabilities for the  
          branch length specified. When the branch length is 0, 
          then instead of transition probabilities (which are 
          all 0 except for the diagonals, all 1) the prior 
          probabilities for each combination are shown (calculated 
          according to the current settings of "lset sprior",  
          "dependence", &c). 
 
VVERSION
    show version 
 
WARN
    =   issue warnings 
    -   don't (default) 
 
WATCH
    =   time execution of commands 
    -   don't (default) 
    [  in addition to time, measure RAM (bytes) used by each command 
    [! reset max RAM counter to 0 
    ]  don't (default) 
 
XCOMP
    N    compare steps, character by character, between reference tree and 
         tree(s) N.  Must have defined a tree as reference, with "xcomp =X." 
         If list of trees followed by ">J K" (where J, K are numbers, 0-31), 
         the list of characters with worse fit on reference is placed in 
         character-group J, and the list with better fit in group K. Using 
         "<" instead of ">", it removes characters from groups J, K. 
    *N   same, using fit.  Under auto-weighted optimization, this is the 
         default option. 
 
XGROUP
    define character group(s).  General syntax is as in "tgroup" (but "nod", 
    "siz", or "mono" not allowed). Options "len", "homo", or "score",  
    followed by a tree number, and a comparison (=, <, >, <=, or >=) add  
    or remove from group all the characters for which the comparison (when 
    the character is optimized onto the tree specified) is true.
 
    Examples:  
        xgroup >5 len 0 < 10 ;        adds to group 5 characters with 9 
                                      or fewer steps on tree 0 
        xgroup =4 homo 2 (3,5);       places in group 4 the characters with 3 
                                      to 5 steps of homoplasy on tree 2
 
    The options "min" and "max" are similar, except that no tree is  
    specified in that case. After a list of characters, you can "zap" 
    N characters with "/N" (i.e. "xgroup=0 2. /3;" creates a group with 
    all third positions in the dataset). 
      If you have defined links between characters (with the "xlinks" command), 
    then you can create a group with the characters linked to character C  
    (with "links=C"), or the characters that belong to the complex number 
    X (with "complex=X"). Of course, "links" and "complex" also work for 
    removing or adding characters (with "<" or ">"). In addition to  
    creating groups to refer to characters in a complex, in any context where 
    a list of characters is expected, using "^N" (or "^J.K") amounts to 
    listing all the characters in complex N (or complexes J to K, inclusive). 
      For character types, "type=TYPE" (where type is either num, dna, prot, 
    cont, 1d, 2d, 3d, land, add, nonadd, sank, or disc) places in group all the 
    characters of the specified type. 
      Option "/" automatically creates a group with each data block, and  
    "xgroup !;" saves only active characters. 
 
XINACT
     ;    Deactivate all uninformative characters in matrix 
     *    In nonadditive characters, replace unique (=uninformative 
          states by missing entries (see also "nstates min") 
 
XLINKS
    Define character links. This is based on Goloboff and De Laet (2024, 
    doi 10.1111/cla.12564), and allows for partial dependences between  
    characters/states. This allows reconstructing ancestors in such a way 
    that specific character combinations are mandatory (or preferred), 
    thus providing a way to incorporate ideas from functional dependences 
    into the analysis.
 
      The character dependences are taken into account by internally  
    creating composite characters (as in Goloboff et al. 2021, doi  
    10.1111/cla.12456), representing all possible state combinations  
    (or all allowed combinations) and calculating the transformation  
    costs between all the recoded states. This is all internal and  
    automatic, so that the user does not need to worry much about it.
 
      Note that this supersedes the use of the "smatrix&" option 
    (discussed in Goloboff et al. 2021, doi 10.1111/cla.12456), as it 
    includes inapplicability among the dependences implemented (the 
    "smatrix&" option continues being valid, although it is deprecated, 
    and character names with the specific "smatrix&" format can easily  
    be converted into "xlinks" format).
 
      The group of characters linked by interactions forms a "complex" 
    of characters. It is possible to refer to characters in a complex 
    collectively in two ways, either creating a group of characters with 
    "xgroup" (see "help xgroup"), or by preceding the complex number 
    with "^" in character lists (i.e. "ccode /5 ^4" will give a  
    weight of 5 to all characters in complex 4).
 
      The dependences defined with "xlinks" are taken into account when 
    calculating likelihoods for morphological characters (with several 
    options); the settings affecting likelihood calculations for characters 
    with dependences are described under the "lset" command.
 
    Overview of options: 
        xlink [DEPS] define dependencies DEPS (see below). This uses a syntax  
                     that lets you express complex dependences. Links must 
                     be enabled prior to reading the dataset, with "xlinks=". 
        xlink =      This option has two different interpretations depending 
                     on whether it's used before or after reading data. Prior 
                     to reading, "xlinks=n" enables the use of up to n super- 
                     ordinates per dependent character. Use 0 for disabling 
                     (saves memory; this is the default). If using n=2 or more, 
                     then the name-based syntax of Goloboff et al. (2021) is 
                     internally converted into links with the "smatrix&" 
                     option, thus providing backward compatibility and  
                     eliminating the limit of 32 states when using character  
                     names to specify hierarchies. 
                       After reading the dataset, "xlinks=[DEPS]" reads links, 
                     with a format simpler than the previous option (and  
                     not allowing nested statements of dependence in the  
                     syntax; nested dependences can be defined, but not in the 
                     same statement). As nested definitions are not allowed, 
                     the syntax can be simpler, using only "<" and ">" 
                     for dependent character(s) (which can have rules, but  
                     without using "{ }" as with nested statements). The 
                     ":" symbol is not needed for distinguishing states that  
                     determine others from those that are determined by others 
                     (states within "< >" are always determin-ed, and those 
                     outside, determin-ing). the use of "!" is not allowed  
                     (as the symbol is unnecessary). Although with this simpler 
                     syntax you cannot have nested statements (e.g. as in the 
                     case of "0 :0 <1 - :-0  <2 -> >"), in many cases you 
                     can have simpler definitions (i.e. "0 0 <1 -> 1 -0 <2 ->"). 
                     Choose the syntax that is most convenient for you. Note 
                     that the use of "xlinks:", as well as the "[ ]" and "/" 
                     options, are unaffected by the use (or not) of "xlinks=". 
                     All the DEP examples below use the default "xlinks" (i.e.  
                     without "="), but (unless using multiple levels of depen- 
                     dence) they could equally have used the syntax with "=". 
        xlink - L;   unlink complex(es) in list L. 
        xlink ]      disable any defined links (but without un-defining them; 
                     they can be subsequently re-activated with "xlink[;"). 
        xlink [      re-activate any deactivated links. 
        xlink <      if several rules imply different penalties for the same 
                     set of linked characters, use the smallest 
        xlink >      if several rules imply different penalties for the same 
                     set of linked characters, use the largest 
        xlink +      if several rules imply different penalties for the same 
                     set of linked characters, use the sum 
        xlink &N     when several (two-state, symmetrical) characters in the 
                     same complex are compatible, they can be recoded with fewer 
                     states (yet producing identical results). With N=1 [default], 
                     try to compact the representation; with N=0, exhaustively  
                     enumerate all combinations. This trick can be applied only 
                     to characters that are applicable for the same state(s) of 
                     a primary character; it is not applicable to characters  
                     with restrictions on the possible states, or transformation 
                     costs that depend on the states (or changes) in other 
                     characters.  
        xlink |N     with N=0 [default], calculate homoplasy for unobserved  
                     applicables having one of the observed states. 
                       With N=1, allow for unobserved applicables to have a new  
                     state (i.e. different from all those observed in the matrix; 
                     this is, less homoplasy). The "1" can be followed by "=L", 
                     where L is the list of characters where unobserved appli- 
                     cables can have a new state (i.e. this interpretation may 
                     be more sensible for some characters than for others); by 
                     default, all can. An "=" with no list just displays the 
                     list of characters where unobserved applicables can be  
                     assumed to have a new state. 
                        With N=2, substitute each unobserved applicables in the 
                     dataset by a unique state,and then set N to 0 (this has, of 
                     course, a maximum of 32 states, which N=1 does not). The "2" 
                     can be followed by "=" and a list of list of the characters 
                     to convert (default=all). 
        xlink @N     for nonadditive characters with some uninformative (=unique) 
                     state(s), there is no need to consider those unique states in 
                     combinations other than those occurring at the terminals having 
                     them. This may save some combinations to recode in the case  
                     of nonadditive characters; it may also prevent some combinations 
                     of original states that would produce most parsimonious  
                     optimizations (MPRs) to occur at HTU's. With "@0" [default], 
                     TNT uses all combinations; with "@1", TNT skips all unseen 
                     combinations for uninformative states (often yielding faster 
                     calculations, but possibly overestimating homoplasy if the 
                     complex has at least 3 more characters in addition to the one 
                     with uninformative state(s)); with "@2" combines the unin- 
                     formative state(s) with the states seen in *other* taxa that 
                     also have uninformative states (but only if 3 or more uninfor- 
                     mative states present in character; may miss MPRs, but always 
                     calculates correct scores=. Numbers of states for the three  
                     options are then 0 >= 2 >= 1 (speed, the opposite). 
                        The "@" option can also be used to determine whether  
                     invariant dependent characters are treated as informative 
                     or not. With "xlinks@+" (=default) they are; with "xlinks@-", 
                     they're not (the difference can be checked with "vlinks="). 
        xlink :      define specific costs (or cost penalties), for  
                     combinations of states transforming between each other.  
                     The syntax is:  
                         ch1 from >to ch2 from >to ch3 from >to = cost 
                     "cost" can be an absolute value, or (if preceded by a  
                     plus or minus sign) a penalty or reward). Absolute costs  
                     are applied only when the list of characters (1-3) exactly  
                     matches the composition of the complex (e.g. no matches  
                     when some of the characters in the complex are inactive,  
                     as when jackknifing). The penalty or reward is applied 
                     even if only a subset of the characters included in a 
                     complex specified (and applied to all combinations that 
                     include the set of transformations specified with "xlinks:"). 
                     This can be used to adjust specific transformations not 
                     easily covered with rules established under "[DEPS]". 
        xlink *      define a set of "serial homologs" --characters where joint 
                     changes into the same state (if character nonadditive), 
                     or joint increasing/decreasing changes (if additive) get 
                     downweighted (i.e. a joint gain of a pair of spines in  
                     the first and second pair of legs is not two independent 
                     events, but just one). The downweighting that can be done 
                     without implicit violations of the triangle inequality  
                     in the original characters (IVTI) is mild; TNT automatically  
                     finds the strongest downweighting that can be done without 
                     IVTI's. TNT lets you downweight more strongly, but 
                     this is not advised (see examples below). The syntax is  
                         xlinks * C1 C2 C3 /V ;  
                     The value V (default=smallest value that does not lead to 
                     IVTI) is the number of joint steps beyond which joint changes 
                     are discounted. As this discounts steps in some characters, 
                     and steps can't be negative, then this is applicable only 
                     when  all the characters in the set have a (prior) weight 
                     larger than unity (otherwise, there can be no steps to 
                     discount). When no V is not indicated, TNT finds the smallest 
                     V that will prevent all IVTI's. With V=0, in the case of  
                     additive characters, only largest increase/decrease is  
                     used as total cost for the simultaneous change; in the case  
                     of nonadditive, only one step is counted if several serial  
                     homologs all end up in the same state. As V increases, so  
                     do the joint steps at which cost begins being decreased  
                     for parallel derivations (or paralllel increases/decreases). 
                     The number of steps beyond which joint derivations are  
                     downweighted last used (this can change as you change 
                     character weights, activities, or additivities) is reported 
                     when you view current links with "vlinks;". 
                     Examples: for weights 2, additive characters, and "xlinks*0 1;" 
                     a joint change 0->2 has a total cost of 7 instead of 8, and a  
                     change 0->2 + 0->1 a cost of 6 (no decreases here); this uses  
                     V=7. With a dataset like:  
                              A  00  
                              B  00  
                              C  21  
                              D  22  
                     and tree (A(B(CD))), the complex is (logically) jointly mapped as 
                            ,--0- A            ,--0- A 
                         --0|   ,--0- B     --0|   ,--0- B 
                            `--0|   ,--2- D    `--0|   ,--2- D 
                                `--2---2- C        `--1---1- C 
                     and the length is calculated as 8 (a change 0->2 +0->1 with cost 
                     6, plus a change 2->2 + 1->2 with cost 2); length difference 
                     with alternative resolutions is 5 steps (instead of 6). For 
                     the same dataset, but V=5, the tree length is now 7, and the  
                     difference with alternative resolutions 3 steps (i.e. smaller). 
                     The catch is that the complex can now be jointly mapped like  
                     before, or equally well as:  
                            ,--0- A            ,--0- A 
                         --0|   ,--0- B     --0|   ,--0- B 
                            `--0|   ,--2- D    `--0|   ,--2- D 
                                `--2---2- C        `--2---1- C 
                     Note common ancestor of CD having an increase followed by a 
                     decrease for the second character, because of the smaller V 
                     value. With even smaller values of V, difference with  
                     alternative trees continues decreasing (down to only 2 steps 
                     for V=4 or less), but then other unusual joint mappings also 
                     become equally optimal, because of IVTI's. For V=2 or less: 
                            ,--0- A            ,--0- A 
                         --0|   ,--0- B     --0|   ,--0- B 
                            `--0|   ,--2- D    `--0|   ,--2- D 
                                `--1---2- C        `--1---1- C 
                     Note common ancestor of CD having a state different from that 
                     of its two descendants for the first character. To prevent 
                     IVTI's like this, it is advisable to rely on TNT's automatic 
                     calculation of V values and to skipp the /V specification.
 
                        The restrictions just discussed do not apply under 
                     likelihood; in that case, for comparability, the larger the 
                     value defined with "/V", the milder the decrease in  
                     probability of joint transformations. A difference with  
                     parsimony is that multiple transformations into each of 
                     different states (e.g. from 0,0,0,0,0 into 1,1,2,2,2) have  
                     a rate of 0 (as if they were two changes in two independent 
                     characters). In the case of additive character (which are  
                     treated just like nonadditive characters in the Mk model), 
                     multiple increases or multiple decreases have a rate (i.e.  
                     decreased probability), but transformations implying incre- 
                     ases in some characters and decreases en others, have a  
                     rate of 0. 
    With specification of DEPS, three kinds of dependencies can be defined,  
    classified in two types:
 
      static dependencies:  
          * applicability/inapplicability of some characters, on the basis 
            of the states of other character(s). 
          * plausible ancestral reconstructions, so that some ancestral 
            combinations are banned or penalized (e.g. ancestors must be 
            reconstructed so that if character N has state x, then 
            character L can only have state(s) u, v, but not w). 
      dynamic dependencies:  
          * This does not ban any ancestral combinations, but gives a  
            differential cost to transformations i->j of character X  
            occuring in areas of the tree where character Y has a given 
            (combination of) state(s) (indicated with ":"), or character 
            Y has a certain state change (indicated with "/", see below). 
            If you use this, and want to make sure you avoid effects like 
            described above for serial homologs ("xlinks*"), you can 
            use a penalty (or step discount) that is less than a step (e.g. 
            upweighting all characters by 10, then using penalties or step 
            discounts of up to 9)
 
      In every case, it is possible to have the condition in the superordinate 
    character(s) defined as a series of AND/OR conditions, so that a character 
    depends from several other superordinate characters. It is also possible 
    to use AND/OR conditions for the subordinate characters themselves, see  
    below for the use of "{ }".
 
      The syntax for specifying dependences is derived from that used in anagallis 
    (De Laet 2018), but with some modifications to allow further possibilities: 
        xlinks   
           tail :absent  
              < color - > ;  
             This indicates that color is applicable only when tail is  
             not absent. The "-" symbol can be ommitted (if no states 
             specified, this is taken as "inapplicable", but is best used 
             for clarity). Whenever a list of states is expected (for either 
             parent or dependent character), preceding the list with the 
             symbol "~" (N.B: ASCII 126) indicates the complement (i.e. 
             "not"). This  can be used to express the rules more simply. 
        xlinks  
           tail :absent  
              < armature_of_tail - !present >;  
             This indicates that "tail_armature" is inapplicable when  
             tail is absent, and that when a tail originates the armature 
             is expected to be absent (i.e. "not present"). This would 
             correspond to the "birth-death" model of Tarasov (2023), and 
             it may be a reasonable assumption for many dependent characters. 
        xlinks  
           keel :sharp & apophysis :long  
              < hook bent > ;  
             Note that the states hook can take (bent) are just listed (only 
             the states that determine what happens with subordinates must 
             be preceded by ":", e.g. sharp in keel, or long in apophysis). 
             This indicates that if keel is sharp AND the apophysis is 
             long, then the hook (e.g. used to clean in conjunction with 
             the keel and apophysis!) must be bent. The symbols & and | 
             indicate AND and OR, respectively. Expressions for conditions 
             are parsed from left to right; note "x & y | z" is not the 
             same as "z | x & y" (the former always evaluates true  
             whenever z true, the latter never evaluates true unless y is 
             true). You can use parentheses to delimit conditions: 
                   z | ( x & y )  
             this expression is now equivalent to "x & y | z" (which trans- 
             lates to "( x & y ) | z ").
 
      For specific state combinations, you can penalize transformations into 
    and from that combination, instead of banning them completely (this is 
    not possible for inapplicables, only for specific states). For this,  
    use a "+" followed by the penalty right after the opening "<" of the 
    subordinate character(s):
 
                xlinks keel :sharp & apophysis :long <+1 hook bent >
 
    This penalty is not multiplied by the weight of the characters (because 
    penalties can also be applied when several characters are subordinate 
    with some conditions themselves --i.e. with "{ }", see below-- and  
    the multiple characters can have different weights). Thus, each penalty 
    is constant, not depending on character weights. 
      If any state sub-depends from hook, you can add determining states and 
    continue using further "<" and ">" to assemble the hierarcy:)
 
         xlinks 
           keel :sharp & apophysis :long  
              < hook bent :straight  
                  < tip_of_hook red > 
               > ;
 
    Should the tip_of_hook depend on another character in addition to  
    hook (e.g., legs, a character which does not itself depend on keel 
    and apophysis), you can either split this in two statements of  
    dependence:
 
         xlinks 
           keel :sharp & apophysis :long  
              < hook bent > 
           hook :straight & legs :colored  
              < tip_of_hook red > 
           ;
  
    Or use the "!" symbol to indicate that legs does not depend on the 
    previously specified superordinates (i.e. legs need to have no 
    specific states when keel sharp and apophysis long):
 
          xlinks 
           keel :sharp & apophysis :long  
              < hook bent :straight & legs ! :colored  
                  < tip_of_hook red > 
               > ; 
 
      All of the previous examples concern the case where a subordinate 
    character can take some states depending on a combination of states 
    of some superordinate characters. Sometimes one may wish to specify  
    that for some combination of states in the superordinates, there are 
    only certain alternatives in several subordinate characters. This is 
    done using "{ }" instead of "< >", and using the same syntax for 
    the conditions, e.g.:
 
          xlink 
             diet :carnivorous & tail :lunate 
               { ( upper_teeth incisor & lower_teeth molar ) | 
                 ( upper_teeth molar & lower_teeth incisor )  
                } ;
 
      With this, either the upper or lower teeth (but not both!) must be 
    incisor when the diet is carnivorous and the tail is lunate. That is, 
    the combinations of molar/molar or incisor/incisor in upper/lower teeth 
    would be banned. Note that using "{ }" is only needed when there are 
    some OR alternatives; if there are only AND alternatives, those can 
    always be handled by the use of "< >". As in the case of "< >", 
    instead of completely banning some ancestral character combinations, you 
    can just penalize them (as before, with "+" after the starting "{").
 
      The dynamic links are specified, after superordinates and their  
    conditions, by using "[" and "]" (instead of "< >" or "{ }"):
 
         xlinks 
            wings :small  
              [+2 flight slow > fast ];  
           This indicates that transformations from flying fast to  
           slow cost an extra 2 steps if occuring in a branch where 
           wing size is being reconstructed as small (note that only  
           the descendant state of the superordinate is considered 
           here).
 
    If you need the altered cost to apply when both ancestor and descendant 
    follow the rule for the superordinate character(s), instead of just 
    the descendant, use a double "[[" when specifying the subordinate 
    character (in that case, of course, you must also close with "]]"). 
    A case where this might be useful is, e.g. to differentially weight 
    silent substitutions in DNA sequences (which mandates that both  
    ancestor and descendant must follow the rule, i.e. for a given  
    aminoacid).
 
      For dynamic links, you can alter the cost of a given transformation on 
    the basis of changes in the superordinate character (instead of the 
    states present in the ancestor/descendant). In this case, the primary 
    character is followed by "/" and the change (the change, with syntax  
    to that in the dependent character):
 
         xlinks 
            wings / small > big  
              [-1 flight slow > fast ];  
           This indicates that transformations from flying fast to  
           slow cost one step less if occuring in a branch where 
           wing size also changes from small to big. If occuring 
           in a branch where ancestor and descendant have the same 
           wing size, there is no change in the cost of slow to 
           fast. If "wing" and "flight" are the only two characters 
           in the complex, this amounts to stating that acquiring 
           a fast flight and big wings simultaneously amounts to 
           a single step (so that, e.g. a group defined by such change 
           could be overriden with a single contradictory character,  
           instead of two)
 
    Note that the conditions in the superordinate characters can be a 
    composite of changes and states (with AND/OR conditions), but if 
    any of the parent characters is indicated as a change (i.e. with 
    "/"), then the only possible subordinate dependence is as  
    a dynamic link (i.e. with "[ ]", not with "< >" or "{ }").
 
      For dynamic links, the penalty can be negative (i.e. make the 
    transformation cheaper), but the total resulting cost can't be less 
    than 1. Keep in mind that if you penalize (or reward) only some of 
    the possible transformations in the dependent character, you can  
    easily get into violations of the triangle inequality; this can be 
    avoided giving all the transformations a higher (or lower) cost 
    (most easily done with "? > ?", where "?" represents "all 
    possible states"). Also, violations of the triangle inequality are 
    more likely with positive than with negative penalties, and when 
    only the descendant is considered (i.e. with a single "[!),  
    so violations may often be avoided by considering both ancestor 
    and descendant (i.e. with a double "[").
 
      Note that the penalty in dynamic links is not multiplied by the 
    weight of the character in question. Note also that by decreasing the  
    cost between what would otherwise be inapplicable states (e.g. from 
    blue to red, or red to blue, when no tail is present), you get in some 
    cases a a sort of gradient between the Fitch interpretation of  
    inapplicables (where any blue->red or red->blue costs exactly the  
    same as when tail present) and the maximum homology interpretation 
    (where blue->red or red->blue would amount to "nothing"). An example  
    would be where genes for tail color are expected to undergo genetic 
    drift if unexpressed, thus having cheaper changes, or less "memory" 
    of the state before tail loss (instead of a "full" memory, as in 
    Fitch optimization). This analogy, however, is far from complete.
 
      You can mix the three types of dependences in one xlink command; if 
    you repeat several xlinks commands, the definitions are added to the  
    existing ones (use "xlinks -", see above, to undefine links, and  
    "xlinks]" to temporarily disable existing links). The "vlinks"  
    command can be used to inspect or save the link definitions, as well 
    as the resulting state recoding and transformation costs. 
 
XMULT
    Run multiple replications, using sectorial searches, drifting,  ratchet 
    and fusing combined.  Options are: 
      hits N             produce N hits to best length and stop 
      replications N     for each hit, search initially with N replications 
      [no]targetscore N  search until score N found (only with fusing) 
      [no]update         do not update targetscore 
      [no]giveupscore N  give up search as soon as score N found 
      [no]rss            use random sectorial searches (settings with 
                         sectsch:options) 
      [no]css            use constraint sectorial searches (settings with 
                         sectsch:options) 
      [no]xss            use exclusive sectorial searches (settings with 
                         sectsch:options) 
      [no]fuse           use fusing (settings with tfuse:options) 
      [no]gfuse N        every N hits, fuse all trees (=score check) 
      [no]dumpfuse       if fusing fails to produce trees of target score, 
                         dump the trees produced by fusing (may prevent 
                         "clogging" of subsequent fuses by keeping only the 
                         most distinct trees) 
      [no]rebuild N      use N cycles of rebuilding (other settings with  
                         "rebuild: options;"). 
      [no]drift N        use N cycles of drifting (settings with drif:options) 
      [no]ratchet N      use N cycles of ratchet (settings with rat:options) 
      hold N             for ratchet, drifting, or rebuilding, save up to N 
                         trees per initial replication (default = 1). 
      [no]autoconst N    use consensus of previous run and initial stages of 
                         current as constraint for initial stages. 1=previous 
                         and wagner, 2=previous and SPR, 3=previous and TBR.  
                         The first replication of a new hit is never 
                         constrained (i.e. hits are totally independent). 
                         Note that level=2 defaults to 1 when "skipspr" 
                         is on. 
      [no]xmix           after unsuccesful fusing, start a new set of  
                         replications as autoconstrained (otherwise, don't) 
      [no]prvmix         if trees existed in memory before running xmult, use 
                         last one to autoconstrain first xmult replication 
      [no]consense N     consense untill consensus is stabilized N times 
      conbase N          base hits to check for consensus stabilizations 
                         (larger numbers make more reliable estimations) 
      confactor N        factor to increase number of hits to check consensus 
                         stabilization (10-100, larger numbers: more reliable) 
      conmax N           maximum new hits to recheck consensus (default=12) 
      [no]keepall        keep trees from all replications.  This has a different 
                         meaning when "hits" is 1 (=default) and when "hits" >1. 
                         When "hits" = 1, it is trees from each of the RAS + TBR + 
                         SS or DFT or RAT, in addition to the trees resulting from 
                         fusing those.  When "hits" > 1, then it means the trees 
                         resulting from fusing the initial starting trees for each 
                         of starting points.  Thus, to find N trees, each resulting 
                         from S starting points (RAS+TBR+etc) and fusing, use 
                         "xmult = hit N noupdate rep S keepall". 
      [no]retouch N      before trying new replications, repeat sectorial 
                         search and ratchet/drifting 
      level N            set level of search (0-10). Use 0-2 for easy data 
                         sets, 2-5 for medium, above 5 for difficult. If N  
                         followed by a number T, set level for T taxa; otherwise, 
                         set level for currently active taxa. 
      chklevel N         check search parameters during run, every N hits. 
                         The parameters are increased or decreased, starting 
                         from user settings.  If N is preceded by +F (between 
                         0 and 2), the entire level is changed by F. If N is 
                         preceded by -, user settings are starting point 
      [no]multiply       after hitting target score, find additional trees by 
                         fusing suboptimal with optimal trees (default = yes). 
      [no]verbose        produce verbose reports 
      [no]hybrid         use hybridization; this can be used jointly with  
                         tree-fusing.  Number of hybridizations, rounds, sample 
                         size, and unsuccesful rounds to stop, are set with 
                         the "tfuse" command.  When combined with "picktype", 
                         a number x F can follow "hybrid" --this is the factor 
                         to multiply the number of replications if "hybrid" is  
                         chosen instead of "fuse".  Fusing normally needs fewer 
                         trees as input (it is for more structured data sets), but 
                         when "pick" is used, genetic algorithm is determined at 
                         run time, thus user cant't predict ahead of time which 
                         genetic algorithm will be used.  As example, with "pick  
                         hybrid x4 repl 5", if fusing is picked, then it will use 
                         (initially, at least) 5 replications for fusing; if  
                         hybridization is picked, then it will use 20 replications. 
      pcoord 1           for use only within slaves, when all running "xmult" 
                         simultaneously, when several hits to a minimum score requested. 
                         This exchanges values of best scores between tasks, so that 
                         each one knows the best score found by the others, and attempts 
                         to reproduce that best score. Of course, this is invalid when 
                         running "xmult" within parallel sectorial searches (scores 
                         for different sectors ain't comparable!). Obviously, if  
                         different tasks are running different datasets (e.g. some 
                         deactivate some characters, others, others) this can lead 
                         to some tasks attempting to hit irreproducible scores; use 
                         it cautiously, if you have some idea of what you're doing 
      pcoord 2,3         as in 1, but use some tasks as "fusers", to process the 
                         trees built by the other tasks ("builders"). This can be 
                         followed by ":N", which is the group size (builders+fuser); 
                         if N is smaller than tasks, you may have several fusers  
                         (i.e. about tasks/N fusers). In the case of 2, these fusers 
                         work separately from each other; with 3, they communicate the 
                         best scores found and all try to hit the same scores. Using  
                         an asterisk (*) after "2:N" or "3:N", the first replication 
                         in each builder autoconstrains by reference to a RAS Wagner  
                         tree (so that CSS can be applied to the first replication). 
                         Using an ampersand ("&") together with 3, when a fuser 
                         finishes, it tells the builders to pause (so as to not  
                         continue using CPU time while the rest of fuser/builder 
                         groups try to catch up), with builder resuming work only if 
                         other fuser/builder groups find a better tree. 
      pcoord 4           centralize consensus stabilization in a task; all tasks 
                         produce (or try to) hits to the optimal length (this turns 
                         on the option "pcoord 1", so that all tasks know the global 
                         best score), but the consensing of the hits is centralized 
                         on task 0. This option requires that you specify "consen". 
      [no]picktype N     use either fusing or hybridization, choosing with  
                         threshold N (see under "tfuse"). This uses only one 
                         type of genetic algorithm; if you want both to be used, 
                         just set them both.  If using "verbose", then choice is 
                         indicated on screen. 
      [no]hfuse N        every N hits to minimum length, hybridize all resulting 
                         trees as an extra check for optimality. 
      ras,cas,ias,       select type of addition sequence for the Wagner trees (if 
          sas,fas        not specified, the one last used with "mult" is used). 
    Options are set with "xmult:options;" or "xmult=options;" (using 
    ":" only settings are changed; "=" runs as well). With "xmult:;" 
    current settings are displayed.  If consensing, / followed by a taxon list 
    removes the specified taxa from the consensus (this must follow all the 
    other options).  If css, rss, and xss are specified css is done first, 
    then rss, and xss last.  Rebuilding, ratchet, and drifting (in that order) 
    always follow sectorial searches.  Global hybridization and/or tree-fusing 
    are done last (although they may be done as part of rebuilding, ratchet,  
    or drifting). 
 
XPERM
    N/L;   permute states within character(s) N, for taxa L 
    -;     undo last permutation 
 
XPIWE
    Handle options for extended implied weighting 
      -    set extended options OFF 
      =    use extended implied weight (use character sets for constant 
           or "set weighting", and/or different weighting strengths for 
           different characters). Character sets defined with "xpiwe[" are  
           weighted using average homoplasy in the set.  For a set of N  
           characters with total homoplasy H, the score for the set is 
                                    (H/N) 
                              N * ---------  
                                  (H/N) + k  
           Sets defined with "xpiwe/" have constant weight. Note that set 
           weighting is peculiar in making parsimony-uninformative characters 
           relevant to the analysis; for set weighting, when user-defined 
           weighting functions are in effect, TNT needs to extrapolate costs 
           (since it uses average numbers of steps). When combining different 
           weighting strengths in an analysis, the fitting function for all  
           characters is rescaled so that the first extra step (i.e. no  
           homoplasy) costs the same for all characters.  
           NOTE: extended implied weighting is valid only under "piwe=",  
           not "piwe+", and to apply it you must read the data with  
           implied weights turned ON.  
      /    define a set of characters with constant weight.  Usage is:  
           /NxF L, where L is the list of characters for which every step 
           costs the same as F times the cost of adding 1 step to a 
           character with N extra steps (under the "base" concavity,  
           or the user-defined weighting function). 
      [L   define a set of characters (L) for homogeneous "set weighting".   
           If L is (optionally) followed by "=N", then the set L is 
           divided in subsets or "chunks" of N consecutive characters  
           each.  If L is followed instead by "/" and a partition  
           (e.g. in the form "12:3" or "1:2:3") then the first, 
           second, and third positions within list L are grouped. Not 
           specifying 1, 2 or 3 leaves those positions outside the subset(s). 
           NOTE: when user-weighting function are in effect, weighting-sets 
           require calculating fit for fractional (i.e. non-discrete)  
           numbers of extra-steps; this is done by interpolating (on 
           the fitting function assembled from the user-defined cost 
           function) using the same interpolator of the macro expression  
           "intpol". 
      ]    like previous one, but it does all data blocks automatically 
           (e.g. "xpiwe]/12:3;" creates a set for 1st and 2nd position, 
           and another with 3d, for each of the data blocks, while  
           "xpiwe]=10;" divides each of the data blocks in chunks of  
           10 characters each) 
      *    write to log file the list of characters in weighting sets,  
           and the list of characters with fixed weights, in a format  
           readable by TNT 
      &L   report status of weighting sets for tree(s) in list L.  If list 
           preceded by strings "steps", "score", "homoplasy", or  
           "size", then it reports the corresponding value (default is 
           "size").  Under different concavities, you can also report 
           the concavity values of each set ("kvalue") or cost of adding 
           a step to an average character in the set ("cost") 
      !L   remove characters in list L from weighting sets and from the set of 
           characters with fixed weight. 
      (    handle implied weighting with different concavities for different 
           characters. The symbol "(" can be followed either by "*" or by 
           a list L of characters.  The "*" (see below) determines different 
           weighting strengths based on numbers of missing entries; with a  
           list L, the user defines the concavity for the characters  
           specified in L.  N.B.: the values of concavities (or the cost  
           of adding steps for the different characters) are shown by the  
           "piwe&" command, not by this one. 
           (* Option:  
              This option is intended to address the problem that characters  
              with many missing entries cannot have much homplasy, and thus  
              normally have high implied weights during analyses. With  
              "( *P <M /K", missing entries are assumed to have (for the  
              purpose of calculating fit differences) a proportion P of the  
              homoplasy which occurs in observed entries .  Thus, if P is 1  
              and half the cells in a character are missing entries, the cost  
              of adding a step to a character with H extra steps is (approxi- 
              mately) the same as the cost of adding a step to a character  
              with 2H steps. If no P is specified, the default (0.5) is  
              used.  When reading the matrix, inapplicables (which should  
              not increase the counts of missing entries!) can be indicated 
              with the symbol "*" (=set of all states but the largest).  
              The approximation used with the default weighting function 
              function is based on using different K values, given that for  
              the standard weighting function, the cost of adding a step to  
              a character with N extra steps, under K1, is approximately the 
              same as adding a step to a character with N.K1/K2 extra steps  
              under concavity K2.  Thus, characters with more missing entries 
              get lower K values (i.e. they decrease their influence more  
              quickly as homoplasy increases, but are equally influential in  
              the absence of homoplasy).  M determines the maximum acceptable  
              ratio between K1/K2 (1<=M). If no M is specified, the default  
              (5) is used.  The value K determines the "base" concavity (i.e.  
              the concavity for a character with no missing entries); if "/K" 
              not included, general concavity is used.  Note that P=0 or M=1  
              are equivalent to standard implied weighting.  If weighting sets 
              have been defined (with the "xpiwe[" or "xpiwe]" options), TNT 
              will honor those sets (extrapolating from the average homoplasy 
              in the observed entries to the total missing entries in the set).  
                 When a user-defined weighting function is in effect, then the 
              K values are used as factors for extrapolation to missing entries 
              (a character with concavity K, under general concavity G, is 
              considered to have G/K times the homoplasy observed in the 
              non-missing entries).  Remember, this means that the cost of 
              adding a step to a character with S steps is the same as the cost 
              of adding a step to a character with G/K times the observed 
              homoplasy, not G/K times the step cost!  The interpolator uses 
              the cost function defined by the user (not the fit function  
              assembled from it; note that the two options might produce  
              slightly different results).  
           (= Option;  
              similar to previous one, but use K values that best approximate 
              the ratios in proportion of missing entries (calculated with a  
              heuristic). When a user-defined weighting function is in effect, 
              this option defaults to the previous one. 
           (L Option:  
              with "(L /K", all the characters in list L get concavity K.  
              Initial concavities can be set with the previous option, and  
              then modified with this one (case in which TNT will honor the  
              last set of concavity values determined by the user). Keep in  
              mind that if weighting sets have been defined, all the  
              characters in a set must have the same concavity!  When user- 
              defined weighting functions are in effect, k is used (as in the 
              previous option) as a factor to extrapolate. 
      )    use a single concavity (or user-defined weighting function) for  
           all characters.  
 
XREAD
    Read data; Hennig86/NONA format. Basic format for reading data:
 
         xread  
         'Title (within single quotes)' 
         NC NT 
         (matrix) 
         ;
 
    Interleaved format: each block preceded by "&" and block options 
    within square brackets.  Block options are: 
       continuous     continuous 
       dna            DNA data  
       proteins       aminoacid data 
       numeric        alphanumeric data 
       landmark 2D,3D read two- or three-dimensional data (landmark coords.) 
                      Each "character" can consist of several points; use 
                      "|" to separate characters, and ? for missing. 
       gaps/nogaps    read gaps as fifth state / missing 
       trimhead       if data are DNA or AA, and gap is fifth state, 
                      make all leading gaps missing entries 
       trimtail       likewise, for trailing gaps 
       match N        consider names of similarity N, as the same 
                      the same taxon (with 1 identical) 
       verbose        give stats for each block 
       /blockname     name block as "blockname".  Subsequently naming 
                      blocks with cnames command overrides these names.
 
    Simple "data" blocks in Nexus formats can be read. Nexus files in 
    "taxa" and "characters" blocks cannot be read; if you have data 
    in such format, easiest course of action is reading with PAUP*  
    and saving to a new file with
 
           export file=newfilename format=nexus nexusblocks=data;
 
    then reading "newfilename" into TNT with:
 
           procedure newfilename;
 
    Character and state names can be imported into TNT with the "cnames" 
    command, but only from a "CHARSTATELABELS" block. PAUP* does not 
    save data in such format, but Mesquite does.
 
    Editing data: 
         =C T S  set states for taxon T, character C, to set S. 
                 If C and/or T is within square brackets, then C and/or 
                 T can be lists of characters/taxa. If C is a landmark 
                 character (=config.), then C must be followed by the 
                 number of landmark to set (first landmark in the 
                 config = 0), and S given as two or three comma-separated 
                 values (depending on whether config. is 2D or 3D). 
                 Note: If the character number is given as "?", then TNT 
                 will convert matrix cells into missing entries, where:  
                      xread = ? Pc Pt 
                 Pc is the probability (0-1) of selecting a character; if  
                 a character selected for introduction of missing entries,  
                 a probability Pt (0-1) is used for selecting taxa. This  
                 depends on current random seed. 
         =!C T S same, but do not re-check minima-maxima (saves 
                 time, but unless "xread ==;" is used, subsequent 
                 optimizations may be wrong.  Use with caution!) 
         ==      check informativeness for all characters (=undoes 
                 possible side-effects of previous one). 
    Saving data: 
         *       all chars.  (followed by "*" also saves char. settings) 
         -       only active  (followed by "*" also saves char. settings) 
                 In the case of landmarks, it does not save landmarks with 
                 zero weight. 
         [       only active, randomizing order of characters (=mangling) 
                 Not valid for landmark characters. 
         !T/C    save only taxon names and chars. (no xread, no ccode), 
                 for taxon list T, character list C (default=all). 
                 If list T preceded by "(N)" (where N is a tree-number), 
                 then T may contain a list of HTU's for tree number N. 
                 In the case of landmark configurations, you can specify 
                 the individual landmarks L to save as "<L>". Analogously 
                 to "map", using ":" instead of "!" invokes the down-pass 
                 (instead of final) state sets for internal nodes. 
    Generating data:  
       /C T N;       random data with C characters and T taxa (each of N states 
                     equiprobable at each cell) 
       +T P C N;     Neyman/Jukes-Cantor data, using tree T as model, probability 
                     of stasis P (0-100), C characters, and N states.  If P = 0 , 
                     then it assigns branch lengths at random. If "T P" is replaced 
                     by "!", then branch-lengths in tree-tags are used (and tag-tree 
                     is used as model tree). 
       >T P N L      as previous one, but L is the list of characters to generate. 
                     ("T P" can also be replaced by "!"). 
       <T M1-M2 S L  generates data with a length uniform for all branches, varying 
                     between characters (for each character, length is taken from 
                     interval M1-M2, uniformly), with S states, for characters in  
                     list L. 
       &(X) T S L    generate data using an exponential function (lambda=X) to 
                     assign probability of homoplasy; distribute changes randomly 
                     on branches of tree T, with S states, for characters in list 
                     L.  If "(X)" skipped, default is 0.05 (or last value used). 
                     If no S specified, S=2; if no list L specified, it does no 
                     character. 
 
XWIPE
    Remove data set from memory (allows changing settings) 
 
UNIQUE
        discard duplicate trees (without collapsing) 
    *   collapse first and then discard duplicates 
 
UNSHARED
    =   prune unshared taxa from trees when calculating consensus (default) 
    -   don't 
 
USMINMAX
    N =M  set minimum number of steps for (sankoff) character(s) N to M 
          (if 0, turns user-minimum off for the character(s) specified). 
    *     save to log file the user-minima for sankoff characters, in a  
          format that can be subsequently input into TNT. 
    !     determine user-minimum for each sankoff character with a tree- 
          search. This is done for current cost and ancstates settings; 
          if any of those settings changed, repeating calculation of minima 
          may be advisable 
    +M N  set maximum number of states for all Sankoff character(s) N to M 
          (in optimization, try those states even if absent in terminals). 
          This does NOT apply to sankoff characters which correspond to a  
          character-state tree, which always use the actual maximum. 
          A different maximum can be defined for different characters, 
          and it can be collectively turned on/off with next option. 
          When defining maxima with "+", they're initially active. 
          N.B. this also affects likelihood calculations with "xlinks"; 
          the definition of user maxima needs to be done *before* defining 
          the links with "xlinks" for this to work. 
    [     If user maximum states defined, apply them. 
    ]     Do not apply user maximum states (keep definitions, though, so 
          they can be turned on again with "]"). 
 
ZZZ
       Go to sleep!! (=quit) 
 
BANDB
    Generate all trees, and execute [commands] for each one 
    Syntax is:  
      
         bandb   [ commands ] ; stop  
      
    The trees generated include intermediate trees; the generated 
    tree is always the last one in memory (if no trees existed when 
    bandb started, then tree 0).  The tree can be modified or copied 
    onto other trees with [commands].  After bandb finishes, it leaves 
    a polytomous tree as tree 0 if bandb started without trees, or as  
    the Nth tree if N trees were in memory (this is done so that  
    tree-numbers continue being the same as within bandb). 
      
    Within bandb, the following commands are recognized: 
      
       cutbranch    don't continue descending into search tree 
       continue     skip subsequent instructions for this tree 
       endbranch    interrupt process 
      
    When running bandb, variables percswap, bbfull, and bbtax 
    are recognized. 
 
BARPLOT
    make bar plots (or heat maps), as SVG files
    Call repeatedly to open, plot, or close file.
    Options:
       open xxx    open file xxx for subsequent plotting (if warnings
                   in effect, query before overwritting file).
                   Sub-Options posibly following "open":
                      size X Y      give size of frame (default 500,300)
                      numcols       numbers of columns to plot (needed
                                    for number of bars in graph; use varsize
                                    if unknown)
                      width         give column width (default=20)
                      separation    give separation between columns (default
                                    is plot width divided by numcols, minus
                                    column width)
                      font          give font size (default 30)
                      color         give background color in RGB
                      extrax N      leave extra space left of graph (e.g.
                                    for writing legends)
                      extray N      leave extra space below graph 
                      tiled CxR     do multiple tiled graphs, C columns, R rows
       title       copy title (end with semicolon), at current graph. If 
                   title preceded by "-N" or "+P", it moves the title
                   N points to the left or right, respectively.
       graph C R   if opened tiled graphs, move to graph in column C, row R;
                   resets legend positions and number of plotted columns
       font N      size of font for legends (X-axis)
                   Sub-Options posibly following "font":
                      italics       ditto 
                      normal        ditto 
                      scale N       font size for scale (legends of y-axis)
       usmax N     define maximum value to plot (top of graph), use 0 for
                   maximum to be defined from plotted array
       usmin N     define minimum value to plot (bottom of graph), use 0 for
                   minimum to be defined from plotted array
       plot var    plot values in variable (array) given as next argument.
                   For each call to plot, relative maxima are used, unless
                   a user-maximum is defined (with "usmax")
                   Sub-Options posibly following "plot" (instead of "var"):
                      usmax N        define maximum value to plot (top of graph)
                      usmin N        define minimum value to plot (bottom of graph)
                      empty          shift space, plot nothing (with N, N slots)
                      color          followed by RGB, define color of plot
                      upcolor        followed by RGB, extend bar to the
                                     top of graph, with specified color
                      notch N        plot variable as a notch of the specified
                                     color (use to subdivide bars ), height N
       reset       change settings
                   Sub-Options posibly following "reset":
                      numcols        reset number of columns (column width and
                                     separation also reset automatically)
                      plot           start plotting again (e.g. to overlay
                                     plots)
                      width N        new column width
                      separation N   new separation between columns
                                     (reset width sets separation to default)
                      shift N        shift columns N points to the right
       legend      label next column with subsequent text (end with
                   semicolon)
                   Sub-Options posibly following "legend":
                      angle N        use angle of N degrees
                      move N         move legends N points down, back to
                                     first column
                      at X Y         write next legend at X,Y (absolute
                                     coordinates, one time only)
                      all +N/K       all column numbers (plus number N),
                                     every K columns
                      yshift N       shift legends for y-axis N points to the
                                     left (use for positioning big numbers)
                      range L H      consider that range for x-axis spans
                                     range from L (lowest) to H (highest); if
                                     followed by "/N", divided in N parts
                                     (10 by default), if by "=N", increase
                                     marks by N.
       divide N    draw lines dividing frame in N parts, and y-axis legends
                   (using as many decimals as set with "macfloat")
                   Optional (instead of parts to divide):
                      =Na Nb...Nn    draws horizontal lines at heights
                                     Na, Nb , ... Nn of graph. Valid only
                                     if "usmax" value defined.
                       /N            draws horizontal lines, every N units.
       heatmap     followed by the name of a two-dimensional variable, plot
                   the values of the variable as an RGB code in a heat-map.
                   Remember that RGB codes are a single number, as R*65536 +
                   G*256 + B.
       close       close graph (no more writing to file allowed!)
 
COMBINE
    Enter a loop, enumerating combinations. Syntax is: 
      
         combine X min/max varname  ...   endcomb  
      
    which enumerates the combination of min out of X elements, 
    then min+1 out of X, min+2 out of X, ... max out of X.  If 
    "/max" is ommited, then max = min.  The elements are written 
    to variable "varname" (must be an array), and listsize equals 
    number of elements minus 1 (keep in mind that listsize can be 
    subsequently modified within the loop, make sure to store value 
    at the beggining of loop if this is so). 
    Using "*" instead of min/max, all possible permutations are 
    generated, saving each to "varname". Beware that number of 
    permutations is much larger than number of combinations. 
    Note: maximum possible recursion of "combine" is the same as 
    for "travtree" and "iterrecs". 
 
CONTINUE
    skip to next loop iteration 
 
COPYTREE
    X Y; copy tree X to tree Y (if no Y is specified, tree 
         X is added as last memory tree). First tree can be 
         specified as: 
           *   copy constraint tree 
           +   copy tagged tree 
           !   taxonomy tree 
         Note:  with the "[" option, if taxonomy is enabled, 
         and a tagged tree exists, then the tags in tag-tree are 
         copied onto the taxonomy; this options also modifies 
         taxon names, so as to contain taxonomy (at least, within 
         available space for taxon names).  Note that this option 
         will collapse untagged nodes in the tagged tree (since 
         they represent no category). 
 
CHKBREAK
    Check for user interrupt 
 
CUTBRANCH
    in bandb, don't descend into search tree 
 
ELSE
    execute subsequent block of instructions when preceding IF not fulfilled 
 
END
    finish an IF block 
 
ENDBRANCH
    terminate bandb 
 
ENDLOOP
    terminate loop 
 
ENDSWAP
    terminate swapping 
 
ERRMSG
    xxx;   call error handler with error xxx 
 
FORFILES
      Loop, for all filenames matching a given string, executing command(s). 
      Syntax is:  
      
         forfiles fname  ... command(s)...  stop  
      
      this will run "command(s)" for all file(s) matching "fname". 
      Within "forfiles", the string "killfiles" interrupts subsequent 
      iterations, and "proc/;" terminates current iteration. 
      The current file is retrieved with "$curfile"; "curisdir" indicates 
      whether current file is a directory.  If you need to indicate spaces  
      within "fname", use the "^" symbol (just like file names in other 
      contexts).  Note that file names containing symbols used as sigils  
      for scripting (symbols ', ", $, or #) are skipped. 
 
GOTO
    fname L [args];   goto file "fname", and start parsing from 
                      point labeled L (with "label L;") 
    =fname;           define "fname" as default target (if this 
                      command run within a slave, and fname is "myself" 
                      then it seeks label within its own istructions) 
    -;                undefine default target 
    [fname L;         define "fname" and "L" as the file 
                      and label to parse AFTER an error/break. 
                      This is intended mostly to allow writing 
                      exit codes for graceful script termination. 
 
HIFILE
    Handle input files (for parsing). 
     =N;               set maximum number of open input files to N. 
     open xxx          open file xxx (can open several at a time; 
                       last) one is set as "active" file). 
     active xxx        set file xxx as active file. 
     list              list open input files. 
     close [xxx ]      close file xxx (if unspecified, close 
                       active input file). 
     skip [xxx ] N     skip N bytes (default=1) from file xxx (if 
                       unspecified, active file). 
     skipline [xxx ] N skip N lines from file xxx (if unspecified, 
                       active file). 
     seek [xxx ] C N   read from file xxx (if unspecified, active 
                       file), until character C found (&N=ASCII N), 
                       N times. 
     skips [xxx ] N    skip N strings from file xxx (if unspecified, 
                       active file). 
     seeks [xxx ] S N  find string S in file xxx (if unspecified, 
                       active file), N times. String cannot contain 
                       whitespaces or a semicolon; those can be  
                       indicated with &N (where N=ASCII character) 
     rewind [xxx]      rewind file xxx (if unspecified, active file), 
                       with no need to "close" and "open" again. 
    General: 
        [              the default behaviour when reading a number  
                       from an input file is to eat the terminating 
                       character. This will facilitate parsing in 
                       many cases, but not always. It can therefore 
                       be changed with the next option, "]". 
        ]              do not eat the terminating character when  
                       reading a number with hifnumber. Thus, if file 
                       has "6, ..." , a call to hifspy after  
                       hifnumber returns the 6 would be 44 (a comma), 
                       not 32 (blank). 
    Note that "open" and "active" (which must be given a file 
    name) do not use square brackets around file name, while the 
    other options (for which file name is optional), require brackets. 
    Except for setting maximum number of input files, the other options 
    can be combined together (a semicolon ends execution of hifile). 
    See also expressions hifchar, hifeof, hifline, hifnumber,  
    hifspy, hifstring, and hiftext. 
 
IF
    Take decisions.  Expressions are as in C, but with 
    precedence always evaluated from left to right, for 
    all operations/comparisons.  Use parentheses to change 
    precedences.  Operators: + - * / and bitwise AND/OR/XOR (&|^) 
    Comparisons (==, !=, >, <, >=, <=) take on value 0 or 1. 
    Use && and || for logical AND/OR, and ! for negation. 
    Every IF must be matched by either END or ELSE. 
 
ITERNUCRECS
    Similar to "iterrecs", but it does reconstructions for a complex 
    of linked characters (=nucleus), as defined with "xlinks". The 
    syntax is: 
 
               iternucrecs T N rayname (actions) ; endrecs 
 
    where N is the number of nucleus (=complex), and the array given must 
    be 2-dimensional, with MxT cells, where M is the number of members in 
    the nucleus (given by expression "nucsize"), and T is the number  
    of nodes in the tree. The actual character in position X of nucleus N  
    is found with expression "nucmember[N X]". Inapplicables are written 
    to array as -1. Number of steps is retrieved with "recsteps" 
    ("recsteps[M]" is the number of steps of the Mth character in the 
    complex). 
    N.B. In this case, options /, * or + are not allowed. 
 
ITERRECS
    Loop over reconstructions of a character, writing states to an 
    array.  Syntax is:  
      
               iterrecs T C rayname (actions) ; endrecs  
      
    For every reconstruction of character C on tree T, this stores 
    the values on array "rayname" and executes action(s).  
    Within iterrecs, 'rayname[N]' automatically returns number of 
    state (as a number, not as a bit set; this is different from  
    the "states" expression).  If name of array is preceded by &,  
    then in case a cell (=node) in the array is different from  
    "missing", it considers only reconstructions having that 
    state at that node (if the value is positive or 0), or only 
    reconstructions not having that state (if the value is negative; 
    to forbid state 0, set the value to a negative number between  
    0 and -1, which gets rounded as "-0").  Note that states can 
    be forbidden only for discrete characters. 
       When reconstructions are numerous, it is possible to take 
    a random sample of no more than N reconstructions (where each 
    reconstruction is equally likely to be sampled), using "/N" 
    before the name of the array.  This must generate _all_ the 
    reconstructions, then deliver the sample.  When reconstructions 
    are too numerous to generate them all, you can choose to solve 
    ambiguities randomly, using "\N" instead of "/N" (one of the 
    ambiguous nodes is picked randomly, one of its states is chosen  
    at random, then then rest of the states are recalculated,  
    and this is repeated until no more ambiguous nodes remain, N 
    times). Note that (unlike the "/" option) this does NOT produce 
    a random sample of all possible reconstructions for the character,  
    or the frequencies of the possible states among all reconstructions 
    [consider the case (0(0(?(?1), with two ambiguous nodes and three 
    possible reconstructions]. The seed for the randomized recons- 
    tructions is the general seed (changed with "rseed", not the 
    seed for macros ("macseed"). 
       If character C is continuous, it can be followed by "*D", 
    where D is the increase between reconstructions (otherwise, 
    the interval limits are used).  Using "+" instead, the values 
    written in the array are the (signed) differences between ancestor 
    and descendant for each node (as in blength > or <). 
       Within iterrecs, the string "killrecs" interrupts execution, 
    and expression "recsteps" returns the cost of the reconstruction 
    (if forcing states, this may be larger than minimum length). 
    The command iterrecs can be nested (maximum level of nesting can 
    be set with iterrecs = N; default is 5). Nesting iterrecs may 
    require that "mxproc" is reset as well. 
 
KILLFILES
    Skip subsequent iterations of "forfiles" command 
 
LABEL
    N;     mark point as label (see "goto"). 
 
LOOP
    Do a loop, of the form:  
      
              loop X+Z Y  (actions)  stop 
      
    this repeats (actions) from X to Y, increasing (or  
    decreasing) by Z (default Z = 1).  The expression "#N" 
    is replaced by the value corresponding to Nth loop.  An 
    alternative syntax is:  
      
              loop = loopname X+Z Y  (actions)  stop 
      
    case in which "#loopname" is equivalent to the value of 
    current iteration. The default maximum number of nested  
    loops allowed is 15, but it can be changed with macro* to  
    any number. 
 
MACFLOAT
    Determine floating-point options for macro language 
    =;        floating point calculations enabled 
    -;        use only integer calculations (saves memory space 
              , not speed) 
    N;        if floating point enabled, uses N decimal digits 
              when printing 
              floats (0 uses no digits; equivalent to integer  
              only, but uses more memory) 
    e;        if floating point enabled, use exponential notation 
    *;        if floating point enabled, use default printing mode 
 
MACRO
    =        activate macro language 
    -        deactivate 
    *K N     re-set max. number of loops as K, user variables as N 
    [N       re-set memory to be used by macro language as N (KB) 
    +        in macros, read taxon/character names as numbers 
    !        don't read taxon/character names as numbers 
    prot N   set protection level for macros as N 
                0  no protection 
                1  check accesses to arrays are within dimensions 
                2  prevent re-assembling of multidimensional arrays 
                   by user 
    &N       forbid (N=1) or allow (N=0) comments with double slash 
 
MACREPORT
    =     inform results of comparisons/assignments during macros (=debugging) 
    -     don't (default) 
 
MACSEED
    N   set seed for random number generator for macros 
 
MAKETABLE
        Followed by number/name of one-dimensional array, displays in a table 
        the values for the array (copying everything from the array name to a 
        semicolon into the table title).  If title preceded by "=N", then it 
        displays up to N values in the table.  Using '*' as first argument, 
        it displays two arrays in a combined table.  Maketable is illegal when 
        macro protection is off; combined tables are illegal when floating 
        point is enabled.  Only values >= 0 can be displayed.  In double 
        tables, if one array has more values than the other, the invalid cells 
        are displayed as "0." 
           Maketable can also be used to copy values from tables to arrays: 
        with "maketable + varname;" subsequent invocations of any command 
        which writes (single valued) tables will store the values in array 
        "varname".  Variable "listsize" contains number of values written 
        to array minus 1.  Use "maketable -;" to subsequently turn this off.  
 
PRIVATE
    N;     keep N variables (besides named ones) as private 
 
PROGRESS
    create/update progress bar. Usage: progress j k text, where 
    j= done, k= to do, text= everything until a semicolon is 
    found.  Always must close progress bar with "progress/;" 
    Report can be "refreshed" with "progress=;". 
 
RECURSE
    recursively call the input file being parsed (arguments 
    to "recurse" are passed to the input file) 
 
RESETSWAP
    save current rearrangement and re-start swapping  
    (valid only within tsprit or tbrit commands) 
 
RESETTIME
    re-set time for macros 
 
RETURN
       N;     set value of internal variable "exstatus" to N  
       =      if some variables have been defined within file,  
              close file retaining variables (instead of undefining) 
 
SAFE
    xxx N ;  string xxx can be "vars,", "loops,", or "ram"; it checks 
             whether N variables, loops, or bytes for macro are free, and 
             reports an error otherwise 
 
SET
    Set value of user variables 
      N     set value of variable N to subsequent expression. 
      N $   set variable N as string (semicolon ends). 
            Fixed strings (output only): $dataset, $taxon N, 
            $character N, $state N S, $block N, $agroup N,  
            $tgroup N, $xgroup N, $bitset N, $dnabitset N, 
            $protbitset, $taxonomy N, $curfile, $ttag N, 
            $hifstring, $curwd and $host N. 
              When converting strings on output, the same 
            conventions as for user-strings apply: "$string:N" 
            displays only the first N characters, "$string:-N" 
            the last N, and "$string:+N" all but the first N; 
            for tree-tags only, "ttag::L N" displays only line 
            L of multi-line tag for node N. With "$string<C" 
            you display the characters preceding C, and with  
            "$string>N", the characters following C. 
      +     when converting strings (with $varname), add a blank 
            at the end. 
      -     don't. 
      *     copy and operate between arrays. Syntax is:  
                set * a b + c ;  
            this will set each cell of array "a" to the sum of 
            the cells in arrays "b" and "c".  Possible operators 
            are + - * / & | < > ^. Logical comparisons save value 1 
            (if true) or 0 (if false) to array "a"; possible  
            comparisons are ==, !=, ?> (is "b" larger than "c"?), 
            ?< (the opposite), ?>= and ?<=. If "b" or "c" is  
            a number, a constant value is used (to get from a user- 
            variable, enclose value within parentheses).  If no array "c" 
            specified, then just copies "b" to "a". If "b + c" is 
            replaced by "*N", then every cell is a random number  
            (integer) between 0 and N (inclusive).  An alternative  
            syntax is: 
                set * a += b ;  
            which will sum cells of "b" to "a" (other operators 
            that can be used this way are -=, *=, /=, &=, |=, and  
            ^=).  This can be used to easily initialize or copy  
            arrays without using loops. 
     !a b   sort array "b", writing into array "a" the indices 
            of "b" values in increasing order.  E.g. if values of 
            b = 12, 8, 6, 7, then a becomes = 2, 3, 1, 0. Both arrays 
            must have the same size, and be 1-dimensional.  See "help+ 
            sortlist" for an option to sort only the first N values of 
            an array. 
     :a b   using b as a matrix of distances (symmetric, all diagonals  
            must be zero), performs multidimensional scaling and saves 
            the results (coordinates) in a. Variable a must be an array 
            "a[2 n]" or "a[3 n]" (where n is the number of rows and  
            cols in b; you can use "a[k n]" where k > 3, but then can't 
            plot all those dimensions in a single graph, as max is 2- or  
            3-d graphs). The multidimensional scaling uses a SMACOF 
            algorithm (de Leeuw 1977), with code from Daniel Asarnow's 
            library (https://github.com/asarnow/mdscale) translated into 
            C. The default is an unweighted SMACOF.  To perform a 
            weighted SMACOF, use "/wts" after array b, where wts is a 
            one-dimensional array with n cells (weights for distances 
            from each element to all other elements; in case of conflict, 
            the highest weight is used), or a 2-dimensional array with  
            n x n cells (individual weights; if asymmetrical, the highest 
            weight is used). After running, for either the unweighted or  
            the weighted algorithm, the internal variable "regr" 
            contains the correlation between b and a (the complement of 
            the sum of squared differences between output and input 
            distances, divided by the sum of squared input distances). 
     ~a:C b copy onto one-dimensional array a the contents of column C in 
            two-dimensional array b (a must have the same number of  
            cells as the number of columns --i.e. first dimension-- of 
            array b). 
     ^L S   if L is a lineal array, copy contents into squared matrix S; 
            dimensions of L must obviously match those of S. 
     )a t r if a is an array with x,y,z coordinates of points (in the 
            form of "a[3 n]", where n is the number of points), then 
            rotate points with tilt t (x-axis) and rotation y (y-axis); 
            t and r must be positive (no negative rotations allowed). 
 
SETARRAY
    J,...,K,L  XXX  
           set all cells of variable XXX, of dimensions Jx...xLxK (expression 
           must be followed by Jx...xKxL values, ending with a semicolon) 
 
SETLOOP
    N;     reset loop to N 
 
SLAVEGET
    Get variables from slaves.  Syntax is:  
      
           slaveget [ J T ] mmm ttt ;  
      
    this copies the results from variable ttt in task T of job J 
    onto variable mmm of master.  If no task is specified, the 
    values from ttt on task i are copied onto mmm[i] (or the 
    corresponding section of mmm, if subindices had been indicated 
    for mmm itself, case in which in the number of dimensions 
    in mmm and ttt must match.  In the subindices of ttt, user 
    variables enclosed in single quotes (') are interpreted locally, 
    in double quotes ("), interpreted in slave. 
      An alternative syntax is;  
      
           slaveget [ J T ] mmm + ttt ;  
      
    which sets the cells of mmm to the sum of values in all the slaves 
    for variable ttt. In this case, the dimensions of mmm and ttt must 
    be the same, even if summping results from all slaves. The operators  
    that can be used in this way are the same ones that can be used to 
    operate between arrays (see help for "set *" option); with "+=" 
    instead of just "+" the original values of mmm are added to the sum 
    (likewise for other operators); the ":" operator is added in this 
    case, to average values from slaves (a likely operation, in this case; 
    ":" can save some code). Note that some of the operators (e.g. 
    "^" or "?>") will probably make sense only when getting results  
    from a single task; otherwise, their results may well depend on the 
    order of reception of results from the different slaves. These  
    potentially unstable operators are implemented anyway, but you need 
    to use them with caution! 
 
SLAVESET
    [J T]    set variable in slave T of job J (syntax as in set; 
             no T = all tasks of job J).  User-variables enclosed in 
             single quotes (') are interpreted locally, in double 
             quotes ("), interpreted in slave. 
 
SPRIT
    "sprit N (commands) stop" does SPR to tree N, executing "commands" 
    for each rearrangement (see also resetswap, endswap) 
 
TBRIT
    "tbrit N (commands) stop" does TBR to tree N, executing "commands" 
    for each rearrangement (see also resetswap, endswap, continue) 
 
TRAVTREE
    Loop, travelling a specified tree, T. Syntax is: 
      
          travtree type T N varname (actions) ; endtrav  
      
    in every cycle, the number of node visited is written onto 
    the specified variable. Type can be one of four:  
      
      up    travels tree in an unpward pass, from node N; if "up" 
            is followed by the string "terms" it also does terminals, 
            otherwise it doesn't 
      down  travels in a down pass, towards node N, terminals never 
            included 
      below travels from node N towards root 
      path  travels from node N1 to N2 (two nodes instead of one  
            must be specified for "path") 
      des   visits all immediate descendants of node N 
      
    The variable can be preceded by a minus sign (-), case in which 
    node N itself is not included in the list.  Within travtree, 
    the command "killtrav" ends current travelling, and (in the 
    case of up-passes) the command "skipdes" excludes all the 
    descendants of current node from the loop. 
    Note that the order in which nodes are travelled in scripting  
    commands may not agree with the sequence with which nodes are 
    plotted in tree diagrams.  If you want to make sure that scripts 
    use the same sequence as in plotting, turn this option ON with  
    "travtree +" (OFF with "-"). 
 
VAR
    N;       report name and value of variable N (no N = all vars.) 
    /N;      same, using bits (up to 30) 
    = N XXX; name variable number N as "XXX."  Replacing the N by a '+' 
             names the next variable. Variables cannot be renamed, but 
             variables named within a file can be denamed with '-'.  This 
             allows variables to behave as "static" within a file.  If 
             several variables have identical names, using the name 
             accesses the last one named (e.g. in the current file). 
    :        name variables, using a looser format than with =.  All that 
             is neded here is a list of names (and their dimensions). 
    -N;      dename all variables above N (no N = all variables named from 
             within the current input file). 
    N;       if N is defined as an array, report all the values in the array 
    N*;      same, saving in "setarray" format (readable by the program) 
    +        display a (very simple) graph with the values of two arrays. 
             General syntax is:  
                 var + W [ minx maxx ] H [ miny maxy ] array_A array_B ;  
                 The "+" symbol can be followed by "/x1 y1 x2 y2",  
             coordinates for extra lines to draw (e.g. a frame); up to 15 
             lines can be included in one diagram.  RGB color codes and  
             thickness for the user-lines can be indicated (in parentheses) 
             after the coordinates (default is black, thickness 1). Use a  
             negative thickness for dashed lines. The "+" symbol can  
             also be followed by "-" (only valid when SVG files are 
             used for plotting, see below), which then prints only the 
             user-specified lines (in this case, specification of minx,  
             maxx, miny, and maxy are mandatory, and the specification of  
             arrays A and B must be skipped).  Alternatively, if the "+" 
             symbol is followed by another "+", then a gray background  
             is used for SVG plots; if you want to control the background 
             use "*(R G B)" instead of the second "+" (this is ignored 
             in metafiles; it affects only SVG files). 
                 Using "\" instead of "/", a text to be placed at 
             a specific part of the diagram can be specified; the backslash 
             is followed by x-y coordinates, then RGB color in parentheses 
             (three numbers, 0-255, separated by blanks; RGB code can be  
             followed by stroke and angle, then a closing parenthesis); if  
             no RGB code indicated, black, stroke 1, horizontal text is used. 
             The text follows the closing parenthesis (or the coordinates, if 
             RGB code unspecified), ending with a semicolon. Up to 10 text 
             inserts can be indicated per call to "var+" (use "var+-" 
             to insert more than 10 pieces of text). 
                 The "+" symbol (possibly followed by "+", "-", or line 
             definition), is followed by W, the number of spaces to use on 
             X-axis; H is number of lines to use on Y-axis; minx and maxy  
             are starting and end points of X axis, likewise for Y (if  
             unspecified, min/max values in array used). Maxx and maxy can 
             be followed by "/Div", distance between primary divisions,  
             and this can be followed by the number of primary divisions  
             to use longer tick lines. If the opening square bracket is 
             followed by "!", then the axis legend is skipped (you can  
             also use "var!:0" to skip entirely). 
                 Array_A and array_B are names of (one-dimensional) arrays; 
             the graph plots values of array_B[i] against array_A[i]; if  
             array_A doesn't have the same number of values as array_B, 
             then the minimum number is used; if array_B is not specified, 
             then the graph plots array_A[i] against i (for each of the 
             values in array_A). Both array_A and array_B can be shifted S 
             places (initial S values are ignored), with "+S" after 
             name of the array; the last T values can be trimmed with "-T" 
             (so that the last T values are ignored), or the number of  
             values to use limited to N, with "/N". 
                 The diagram produced can be saved to a metafile (Windows 
             versions; if a metafile has been opened with "log &", then 
             the diagram goes to the file automatically) or an SVG file 
             (previously opened with var ! fname) .  The size of the 
             dots used in the graph can be given (in pixels) after the  
             two variables to plot; if followed by three numbers, in paren- 
             theses, these are the RGB color codes for the dots.  For SVG 
             files, replacing the parentheses by square brackets uses  
             squares instead of circles, and braces, uses diamonds. 
             To draw a line connecting the dots, give RGB color between 
             slashes ("/ R G B /"). The size, color, and shape can also 
             be given as arrays (as for "|"), so that every point has its 
             own size, color, and symbol; arrays must be given as "<array>". 
    |        similar to the "+" option, but plots three arrays (it requires 
             specification of minima/maxima along the three axes, and three 
             arrays. This is valid only if an SVG file is open; it cannot be 
             displayed directly on screen. The "|" symbol can be followed 
             by "(T1-T2,R1-R2)", indicating initial and final tilts (T) and 
             rotations (R); the number of rows and columns is indicated when 
             opening SVG file (see below, under "\"); tilt changes with 
             rows, rotations changes with columns). In a single call, this 
             draws points that are in front of others last. Symbol format 
             can be specified for series of points, if the format is 
             followed by ":N" (where indicates the number of values to  
             show in the specified format). Size and color of symbol can 
             also be indicated with arrays (so that every point has its 
             own size and color), with "<array>" instead of the size or  
             RGB code. The RGB code uses the lowest three bytes (i.e. R* 
             65536 + G*256 + B); the fourth byte (i.e. n * 256 * 65536 )  
             can be used to indicate symbol format, with n = 1 for circles, 
             n = 2 for squares, n = 3 for diamonds, and n > 3 for lines;  
             leave fourth byte as 0 to use the symbol defined globally. 
    !fname   Open file "fname", so that subsequent calls to "var+" save 
             plot to that file, as an SVG file.  If no file name given,  
             it closes currently open file (if any).  Several calls to  
             "var+" overlay plots in the same file. Other options following 
             "var !" are: 
                 = C,R    place diagram at column C, row R 
                 + C,R    move diagram C columns (if C negative, left), 
                          and R rows (if R negative, up) 
                 ! xxx    use xxx as title for a plot at current position 
                 !+n xxx  use xxx as title, with legend x-shifted n points 
                 * n      use a thickness of n points for lines 
                 >S       indicate every point with a legend, fontsize S 
                          (S=0, no legend, default). Optionally, S can be 
                          followed by the x- and y-shift (default 5 3). 
                 :S       font size for legends (or text inserts; use 0 
                          to skip axis legends. 
    \X Y    when saving plots to SVG files, use a width and height X, Y. 
            This must be defined prior to opening the file with "var !". 
            X and Y can be followed by "/S", where S=separator size, for 
            multiple rows/columns of diagrams.  Multiple columns/rows, are  
            indicated as X Y /S x C x R (where C=columns, R=rows). 
    &X Y    linear regression of variables X and Y (must be arrays). If 
            *W follows Y, then weights in W are used. Weights must be 
            between 0 and 1 (if some weights exceed unity, all weights 
            are rescaled; having a point of weight W is equivalent to  
            having W points with those coordinates instead of one). If 
            a number N follows after the arrays, then only the first 
            N values of the arrays are considered in the regression. 
            Results of regression are written into variables regr, 
            regalfa, and regbeta. Specification of arrays (including 
            shifting, trimming, or number of values) is as in "var+". 
 
XEND
    finish any IF blocks in current input file 
    (can save typing "end" repeatedly) 
For help on command "xxxx" enter "help xxxx" 
For help on ALL commands, enter "help*" 
For help with scripting language, enter "help+" 
Enter "help [ topic ]" for possible help topics.
 
COMMANDS: 
    absincl     agroup   alltrees  ancstates        apo     bbreak       beep 
       best    bground    blength     blocks      break   bsupport      ccode 
       cdir     change   chkmoves      chomo      ckeep        cls   clbuffer 
     cnames   collapse    comcomp   condense  constrain      costs    cscores 
     cstree      dcomp     dmerge      drift       edit       echo     export 
       exit        fit   fillsank      force   freqdifs       help       hold 
     hybrid      ienum    incltax       info        log   lintrees       keep 
      kleex     length        lik      lmark      lmbox  lmrealign     lquote 
       lset   majority   matchtax        map     minmax   mixtrees      mkmap 
       mono        mrp       mult      mxram     mxproc      naked     nelsen 
    nstates   outgroup  procedure      pause   pcrprune      pfijo       piwe 
    pruncom  prunmajor prunnelsen    pruntax     prupdn       ptnt  qcollapse 
    qnelsen      quote       quit  randtrees    ratchet     rcompl       rdir 
    rebuild     recons     report     reroot   resample     resols     rfreqs 
     riddup      rseed        run       runc       save     screen     scores 
    sectsch  shortread    shpcomp     silent      slfwt  slaveproc    smatrix 
       sort    sprdiff     subopt      svtxt     system     tables     tagset 
    taxcode  taxlabels   taxonomy    taxname    tchoose      tcomp     tequal 
      tfuse     tgroup     thanks    timeout     tnodes      tplot      tread 
      tsave    tshrink      tsize      ttags     tvault    txtsize      tzert 
       view     vlinks   vversion       warn      watch      xcomp     xgroup 
     xinact     xlinks      xmult      xperm      xpiwe      xread      xwipe 
     unique   unshared   usminmax        zzz 
